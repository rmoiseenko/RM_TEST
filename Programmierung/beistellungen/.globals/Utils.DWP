//##############################################################################
//##############################################################################
//
// Sammlung globaler Funktionen für die "Erweiterte Versandsteuerung"
//
//    Hinweise:
//    - Der Funktions-Präfix 'EVS' steht für 'E'rweiterte 'V'ersand's'teuerung
//
//##############################################################################
//##############################################################################

|
   gl_EVS_BSP_IndiOnlineHelp_SQLWhere:_C       := '',

   gl_EVS_ProzessTyp_Entnahmeschein:_N                 := 10,
   gl_EVS_ProzessTyp_Lieferschein:_N                   := 20,
   gl_EVS_ProzessTyp_Beistellung:_N                    := 30,

   gl_EVS_BSP_TYP_AusStueckliste:_N                    := 10,    // "aus Stückliste"
   gl_EVS_BSP_TYP_Manuell:_N                           := 20,    // "manuell"

   gl_EVS_FRANKATUR_ZuEigenenLasten:_N                 := 10,
   gl_EVS_FRANKATUR_ZuLastenRechnungsEmpf:_N           := 20,
   gl_EVS_FRANKATUR_ZuLastenWarenEmpf:_N               := 30,

   gl_EVS_EVSIsActive:_L := false

|

//##############################################################################
//##############################################################################
// GUI Utils
//##############################################################################
//##############################################################################

//******************************************************************************
// Funktion ruft das Haupt-Fenster der "Erweiterten Versandsteuerung" auf
//    und übergibt eine Parameter-Array zur Steuerung des Fensters
//
//    Die möglichen Parameter können nachgelesen werden im Programm
//    "Versand\Erweiterte Versandsteuerung\Sendungskopf\GUI" in der
//    Funktion "ParseUserDefinedEventParams()"
//
//    Beispiel-Aufruf:
//      EVS_GUI_ShowErweiterteVersandsteuerungAsMdiChild( { {'EVSKOPF_ID',   123 } })
//
// @Result: Formular-Instanz
//******************************************************************************
function _EVS_GUI_ShowErweiterteVersandsteuerungAsMdiChild(aParamArray)
   | oForm |
   oForm := GFU_ShowMdiChild('EVS_VERSANDSTEUERUNG', 'Versand\Erweiterte Versandsteuerung\Sendungskopf\GUI'),
   if not empty(oForm) then
      oForm.CbHelper.CbInvokeUserDefinedEvent(oForm, 'EVS_MAINFORM_PARAMS', aParamArray),
   endif,
   Result := oForm,
end,

//******************************************************************************
// Formatiert eine Gewichts-Angabe in Kilogramm für die Anzeige an der GUI
// @Result: String
//******************************************************************************
function _EVS_GUI_FormatGewichtIntern(nGewichtInKilogramm, bMitEinheit, bZeigeNullWert)
   | nNkStellen |
   Result := '',
   if nGewichtInKilogramm <> 0 or bZeigeNullWert then
      nNkStellen := iif(Abs(nGewichtInKilogramm) < 0.001, 4, 3), // Pfelge im Artikelstamm ist mit max. 4 NK-Stellen möglich
      Result     := FormatStd(nGewichtInKilogramm, nNkStellen) + iif(bMitEinheit, ' KG', ''),
   endif,
end,

//******************************************************************************
// Formatiert eine Gewichts-Angabe in Kilogramm für die Anzeige an der GUI
// @Result: String
//******************************************************************************
function _EVS_GUI_FormatGewicht(nGewichtInKilogramm)
   Result := EVS_GUI_FormatGewichtIntern(nGewichtInKilogramm, true, false),
end,

//******************************************************************************
// Funktion schreibt Porto- und Verpackungskosten in den Haupt-Auftragskopf
// @Result: logisch (true=okay, false=Sendungsabschluss abbrechen)        TBeRightsTable.CbCheckRight_Validate()
//******************************************************************************
function _EVS_GUI_TransferCostToFirstOrder(oDM, oEVSKOPF)
   | oDAB000, oDab050_No_Sto_Filter, oMem050, bPost, nDlgResult, cDlgText |
   Result := false,
   SetErrorIf(not DbInTrans(oDM.AdsConnection), 'not DbInTrans(oDM.AdsConnection): transaction must be active on oDM'),
   SetErrorIf(Empty(oEVSKOPF), 'Empty(oEVSKOPF)'),
   cDlgText := '',
   bPost := true,
   if oEVSKOPF:NKOST_KD and not empty(oEVSKOPF:ANUMMER) then
      oMem050 := CreateObject('TMemCalcTable'),
      oDAB000 := DbGetTable(oDM, waDab000),

      // oDAB050
      oDab050_No_Sto_Filter                   := DbGetTable(oDM, waDab050, 'D050_No_Sto_Filtr'),
      oDab050_No_Sto_Filter.IndexName         := 'DAB051',  // Index: Anummer
      oDab050_No_Sto_Filter.UseLocationFilter := 2,


      MySeek({oEVSKOPF:ANUMMER}, oDab050_No_Sto_Filter),
      if DbWaitLocked(oDab050_No_Sto_Filter, 20, 'Der Auftrag ist momentan gesperrt.', false) then

         if not empty(oDab050_No_Sto_Filter:PORTO) or not empty(oDab050_No_Sto_Filter:VERPACKUN) then
            cDlgText   := 'Die Felder Porto und Verpackung aus dem Haupt-Auftragskopf beinhalten bereits Werte.' + crlf +
            'Sollen die Sendungs-Nebenkosten zu den vorhandenen Werten addiert werden?',
            nDlgResult := BeMessageDlgEx(cDlgText, mtInformation, {'Überschreiben', 'Addieren', 'Sendungsabschluss abbrechen'}, {10,20,30}, 30, 30),
            Result     := nDlgResult = 10 or nDlgResult = 20,
         else
            Result := true,
         endif,
         if Result then
            BeginSuspend(oDab050_No_Sto_Filter),
            startseq
               if AufKopfEdit(oEVSKOPF:ANUMMER, oDAB000, oDab050_No_Sto_Filter, oMem050) then  // TODO: Gesamtes DM muss hier umgeschalten werden => und im always wieder zurück (Warum: Weil AufKopfEdit() im Innenleben vllt. mehr macht als wir hier sehen => "Normale Umgebung" bereit stellen, nicht nur einzelne Tabellen)
                  oDab050_No_Sto_Filter:PORT_PROZ := false,
                  if nDlgResult = 10 then
                     oDab050_No_Sto_Filter:PORTO     := oEVSKOPF:VSKOST_EW,
                     oDab050_No_Sto_Filter:VERPACKUN := oEVSKOPF:VPKOST_EW,
                  else
                     oDab050_No_Sto_Filter:PORTO     += oEVSKOPF:VSKOST_EW,
                     oDab050_No_Sto_Filter:VERPACKUN += oEVSKOPF:VPKOST_EW,
                  endif,
                  AufKopfPost(oEVSKOPF:ANUMMER, oDAB000, oDab050_No_Sto_Filter, oMem050),
               endif,
            always
               EndSuspend(oDab050_No_Sto_Filter),
            stopseq,
         endif,
         DbUnlock(oDab050_No_Sto_Filter),
      endif,
   else
      Result := true,
   endif,
end,

//##############################################################################
//##############################################################################
// Allgemeine Hilfs-Funktionen
//##############################################################################
//##############################################################################

//******************************************************************************
// Funktion zum "Aufräumen" / "Resetten" eine Tabelle aus einem Datenmodul
// => Soll verwendet werden für Tabellen, die den Standard-Alias nutzen
//    damit andere Programmstellen, die ebenfalls diese Instanz nutzen, nicht
//    beeinflusst werden durch hinterbliebene Filter etc.
// => Setzt Scope und Filter zurück und den ersten Index
//******************************************************************************
function _EVS_DbResetDMTable(oTable)
   | aIndexList, cIndexName |
   DBScope(,  oTable),
   DBFilter('', oTable),
   aIndexList := DbIndexList(oTable.Workarea),
   if ALen(aIndexList) > 0 then
      cIndexName := aIndexList[1, 2],
      if not empty(cIndexName) then
         oTable.IndexName := cIndexName,
      endif,
   endif,
end,

//******************************************************************************
// Vergibt das Scoring für die PLZ/Ort-Trennung
// @Result: Rückgabe ist eine ganze Zahl
//******************************************************************************
function _EVS_SeparatePLZORT_SC(cPLZOrt, nLandNr)
   | cNummern, nNummern, nLen |
   nLen := len(cPLZORT),
   if nLen < 4 then  //Definitiv zu kurz
      result := 100,
      exit,
   endif,

   cNummern := charonly('0123456789', cPLZOrt),
   nNummern := len(cNummern),

   if nLandNr=4 then  //Deutschland
      if nNummern=5 and nLen<=7 then
         result := 0,
         exit,
      endif,
   endif,
   result := abs(5-nNummern) + abs(5-nLen),  //Standard-Formel
end,

//******************************************************************************
// Trennt die Informationen PLZ und Ort
// @Result: Array {PLZ, Ort}
//******************************************************************************
function _EVS_SeparatePLZORT(cPLZOrt, nLandNr)
   | oMem, i, nPosPLZ, cOrt, cPLZ, oRec |
   result := {},
   oMem   := CreateObject("TMemCalcTable"), //Memtable über enthaltene Wörter mit Scoring, je niedriger das Scoring desto warscheinlicher ist es eine PLZ
   startseq
      cOrt := '',
      cPLZ := '',
      AddMemField(oMem, "WORT",    "C", 35,0),
      AddMemField(oMem, "SCORING", "N",  3,0),
      AddMemField(oMem, "STELLE",  "N",  3,0),
      oMem.Active:=true,

      //Füllen der Worttabelle
      for i := 1 to TokenCount(cPLZOrt, " ") do
         if !empty(StrToken(cPLZOrt,' ', i)) then
            MyAppend(oMem),
            oMem:WORT    := StrToken(cPLZOrt,' ', i),
            oMem:STELLE  := i,
            oMem:SCORING := EVS_SeparatePLZORT_SC(Trim(oMem:WORT), nLandNr),
            MyPost(oMem),
         endif,
      next,

      //Ermittlung der PLZ
      oMem.OrderBy := "SCORING",
      DBGoTop(oMem),
      nPosPLZ := oMem:STELLE,
      cPLZ    := Trim(oMem:WORT),

      //Ermittlung des Orts
      oMem.OrderBy := "STELLE",
      foreach oRec in oMem do
         if oMem:STELLE <> nPosPLZ then
            cOrt += Trim(oMem:WORT) + ' ',
         endif,
      end,
      result := {cPLZ, cOrt},
   always
      DestroyObject(oMem),
   stopseq,
end,

//******************************************************************************
// Funktion ermittelt den Status einer Senung mittels übergebener und bereits
//    positionierter Sendungskopf-Tabelle (EVSKOPF)
// @Result: string (Sendungs-Status)
//******************************************************************************
function _EVS_GetEVSKOPFStatus(oEVSKOPF)
   Result := 'unbekannt',
   if oEVSKOPF:FLAG = 0 then
      Result := 'offen',
      if not empty(oEVSKOPF:LOESCH_USR) then
         Result := 'gelöscht',
      endif,
   else
      if oEVSKOPF:FLAG <> 0 then
         Result := 'abgeschlossen',
      endif,
   endif,
end,


//##############################################################################
//##############################################################################
// Funktionen für die Volltext-Suchtext-Berechnung
//##############################################################################
//##############################################################################

//******************************************************************************
// Default-Such-Text erweitern
// PrepareTextForFTS für Packmittelstamm
// @Result: Char
//******************************************************************************
function _EVS_PMS_PrepareTextForFTS(nWorkArea, cZielFeld, oEVSPMS)
   Result := '',
   SetErrorIf(empty(nWorkArea), 'empty(nWorkArea)'),
   SetErrorIf(empty(cZielFeld), 'empty(cZielFeld)'),
   // Such-Text zusammenstellen und überflüssige Zeichen entfernen
   Result := PrepareTextForFTS( nWorkArea,
      cZielFeld,
      oEVSPMS:SUCHE + ' ' +
      AllTrim(oEVSPMS:BEZ),
      true ),
end,

//******************************************************************************
// Default-Such-Text erweitern
// PrepareTextForFTS für Packstück-Protokoll
// @Result: Char
//******************************************************************************
function _EVS_PSP_PrepareTextForFTS(nWorkArea, cZielFeld, oEVSPSP)
   Result := '',
   SetErrorIf(empty(nWorkArea), 'empty(nWorkArea)'),
   SetErrorIf(empty(cZielFeld), 'empty(cZielFeld)'),
   // Such-Text zusammenstellen und überflüssige Zeichen entfernen
   Result := PrepareTextForFTS( nWorkArea,
      cZielFeld,
      oEVSPSP:SUCHE + ' ' +
      BeUserName(oEVSPSP:PLATZ) + ' ' +
      AttribDispVal(3004, Str(oEVSPSP:TYP)),
      true ),
end,

//##############################################################################
//##############################################################################
// Gewichtsberechnung
//##############################################################################
//##############################################################################

//******************************************************************************
// Die Funktion stößt die Gewichtsberechnung per SQL-Script an
//   - Die Funktion erfordert ein Datenmodul in Transaktion
//   - alle Tabellen des Versandmoduls müssen beim Aufruf schreibbar
//     sein (nicht gesperrt), sonst kann das SQL-Script nicht durchlaufen
//
//     Hinweis: Damit die neu berechneten Ergebnisse an der GUI sichtbar
//     werden, ist meist ein DbRefresh() notwendig
//
// @Result: null
//******************************************************************************
function _EVS_GewichtsBerechnungPerSQL(oDM, nSendungsID)
   | oQuery, cScriptName, cSQLText |

   SetErrorIf(not DbInTrans(oDM.AdsConnection), 'not DbInTrans(oDM.AdsConnection): transaction must be active on oDM'),
   SetErrorIf(empty(nSendungsID),               'empty(nSendungsID)'),

   oQuery := CreateObject('TBeAdsQuery', 'EVS_GEWICHTS_UPDATE', oDM),
   startseq
      cScriptName := 'Versand\Erweiterte Versandsteuerung\SQL\Gewichtsberechnung',
      cSQLText    := LookUp(waDabPRG, 'BEZ', {{Upper(cScriptName)}}, 'PROGRAMM', ''),
      cSQLText    := StrTran(cSQLText, '@SENDUNGS_ID@', Str(nSendungsID)),      // WriteLn(cSQLText),
      oQuery.SQL  := cSQLText,
      DbExecSQL(oQuery),
   always
      DestroyObject(oQuery),
   stopseq,
end,

//##############################################################################
//##############################################################################
// Warenwerts-Berechnung
//##############################################################################
//##############################################################################

//******************************************************************************
// Die Funktion stößt die Warenwertsberechnung per SQL-Script an
//   - Die Funktion erfordert ein Datenmodul in Transaktion
//   - alle Tabellen des Versandmoduls müssen beim Aufruf schreibbar
//     sein (nicht gesperrt), sonst kann das SQL-Script nicht durchlaufen
//
//     Hinweis: Damit die neu berechneten Ergebnisse an der GUI sichtbar
//     werden, ist meist ein DbRefresh() notwendig
//
// @Result: null
//******************************************************************************
function _EVS_WarenwertsBerechnungPerSQL(oDM, nSendungsID)
   | oQuery, cScriptName, cSQLText |

   SetErrorIf(not DbInTrans(oDM.AdsConnection), 'not DbInTrans(oDM.AdsConnection): transaction must be active on oDM'),
   SetErrorIf(empty(nSendungsID),               'empty(nSendungsID)'),

   oQuery := CreateObject('TBeAdsQuery', 'EVS_WARENWERT_UPDATE', oDM),
   startseq
      cScriptName := 'Versand\Erweiterte Versandsteuerung\SQL\Warenwertsberechnung',
      cSQLText    := LookUp(waDabPRG, 'BEZ', {{Upper(cScriptName)}}, 'PROGRAMM', ''),
      cSQLText    := StrTran(cSQLText, '@SENDUNGS_ID@', Str(nSendungsID)),      // WriteLn(cSQLText),
      oQuery.SQL  := cSQLText,
      DbExecSQL(oQuery),
   always
      DestroyObject(oQuery),
   stopseq,
end,

//##############################################################################
//##############################################################################
// Gewichts- und Warenwerts-Berechnung per SQL
//##############################################################################
//##############################################################################

//******************************************************************************
//
// @Result: null
//******************************************************************************
function _EVS_GewichtsUndWarenwertBerechnungPerSQL_InEigenerTransaktion(oDM, nSendungsID)
   DbStartTrans(oDM.AdsConnection),
   startseq
      EVS_GewichtsBerechnungPerSQL(oDM,   nSendungsID),
      EVS_WarenwertsBerechnungPerSQL(oDM, nSendungsID),

      DbCommit(oDM.AdsConnection),
   always
      if DbInTrans(oDM.AdsConnection) then
         DbRollBack(oDM.AdsConnection),
         DbCancelAll(oDM),
      endif,
   stopseq,
end,

//******************************************************************************
//
// @Result: null
//******************************************************************************
function _EVS_GewichtsUndWarenwertBerechnungPerSQL_InEigenerTransaktion_MitGUIErrorHandling(oDM, nSendungsID)
   startseq
      EVS_GewichtsUndWarenwertBerechnungPerSQL_InEigenerTransaktion(oDM, nSendungsID),
   onerror
      GU_ShowStdErrorMessage('Fehler bei der Gewichtsberechnung für Sendung <' + Str(nSendungsID) + '>', GetErrorObj()),
   stopseq,
end,

//##############################################################################
//##############################################################################
// Sonstige, unsortiert
//##############################################################################
//##############################################################################

//******************************************************************************
// Funktion ermittelt für einen Beleg die zugehörigen Sendungs-ID
//
// @Result: EVSKOPF:ID / 0 wenn der Beleg noch nicht in einer Sendung erfasst ist
//******************************************************************************
function _EVS_GetSendungsIdForBeleg(nProzessTyp, cBelegNr)
   | oEVSSBP, cIndexName |
   if gl_EVS_EVSIsActive then
      Result := 0,

      case nProzessTyp
         of gl_EVS_ProzessTyp_Entnahmeschein :: cIndexName := 'ENTSCH_NR',
         of gl_EVS_ProzessTyp_Lieferschein   :: cIndexName := 'LFS_NR',
         of gl_EVS_ProzessTyp_Beistellung    :: cIndexName := 'BESTPOSNR',
         otherwise                              SetError('unknown @nProzessTyp ' + Str(nProzessTyp)),
      endcase,

      oEVSSBP := BeOpen(Eval('waEVSSBP'), cIndexName),
      startseq
         if DbSeek({cBelegNr}, oEVSSBP) then
            Result := oEVSSBP:EVSKOPF_ID,
         endif,
      always
         BeClose(oEVSSBP),
      stopseq,
   endif,
end,

//******************************************************************************
// Funktion ermittelt für einen Beleg, ob dieser gelöscht markiert wurde
//
// @Result: boolean
//          true:  Beleg wurde gefunden und wurde gelöscht (markiert)
//          false: Beleg wurde nicht gefunden oder Beleg wurde gefunden und <nicht> gelöscht (markiert)
//******************************************************************************
function _EVS_IsBelegMarkedAsDeleted(nProzessTyp, cBelegNr)
   | oDab700, cDab700_Filter |

   Result := false,

   // Beistellungen können nicht "gelöscht markiert" werden
   if nProzessTyp <> gl_EVS_ProzessTyp_Beistellung then

      case nProzessTyp
         of gl_EVS_ProzessTyp_Entnahmeschein :: cDab700_Filter := "(BELEG_ART = 55 or BELEG_ART = 56) AND BELEG_NR == '" + PadR(cBelegNr, 20) + "'",
         of gl_EVS_ProzessTyp_Lieferschein   :: cDab700_Filter := "(BELEG_ART = 60 or BELEG_ART = 80) AND BELEG_NR == '" + PadR(cBelegNr, 20) + "'",
         otherwise                              SetError('unknown @nProzessTyp ' + Str(nProzessTyp)),
      endcase,

      oDab700 := BeOpen(waDab700),
      startseq
         DbFilter(cDab700_Filter, oDab700), WriteLn(cDab700_Filter),
         DbGoTop(oDab700),
         if not NoDS(oDab700) then
            Result := DocDeleted(oDab700),
         endif,
      always
         BeClose(oDab700),
      stopseq,
   endif,
end,

//******************************************************************************
// Funktion prüft, ob für den Versender @nVersenderNr eine Export-Schnittstelle
// verfügbar ist
// @Result: logisch
//******************************************************************************
function _EVS_ExportSchnittstelleVerfuegbarFuerVersender(nVersenderNr)
   Result := false,
   if nVersenderNr > 0 then
      Result := LookUp(waDAB760, 'VERSENDER', {{nVersenderNr}}, 'X_EXPAKTIV', false),
   endif,
end,


//******************************************************************************
// Schliesst die Sendung auf der die übergebene Tabelle EVSKOPF steht
// @Result: null
//******************************************************************************
function _EVS_MarkCloseSendung(oDM, oEVSKOPF)
   SetErrorIf(not DbInTrans(oDM.AdsConnection), 'not DbInTrans(oDM.AdsConnection): transaction must be active on oDM'),
   SetErrorIf(Empty(oEVSKOPF), 'Empty(oEVSKOPF)'),

   if DbEdit(oEVSKOPF) then
      BeginSuspend(oEVSKOPF),
      startseq
         oEVSKOPF:FLAG   := 256,
      always
         EndSuspend(oEVSKOPF),
      stopseq,
      DbPost(oEVSKOPF),
   endif,
end,

//******************************************************************************
// Löscht die Sendung auf der die übergebene Tabelle EVSKOPF steht
// @Result: null
//******************************************************************************
function _EVS_MarkDeleteSendung(oDM, oEVSKOPF)
   SetErrorIf(not DbInTrans(oDM.AdsConnection), 'not DbInTrans(oDM.AdsConnection): transaction must be active on oDM'),
   SetErrorIf(Empty(oEVSKOPF), 'Empty(oEVSKOPF)'),

   if DbEdit(oEVSKOPF) then
      BeginSuspend(oEVSKOPF),
      startseq
         oEVSKOPF:LOESCH_USR := c_usr,
         oEVSKOPF:GELOESCHT  := GetAdsServerTime(),
      always
         EndSuspend(oEVSKOPF),
      stopseq,
      DbPost(oEVSKOPF),
   endif,
end,

//******************************************************************************
// Checkt, ob der aktuell positionierte Beleg in @oEVSSBP der Hauptbeleg
// im Sendungskopf @EVSKOPF ist
// @Result: boolean
//******************************************************************************
function _EVS_CheckIfMainBeleg(oEVSKOPF, oEVSSBP)
   Result := false,
   case oEVSSBP:TYP
      of gl_EVS_ProzessTyp_Lieferschein    :: Result := oEVSSBP:LFS_NR == oEVSKOPF:LFS_NR  and not empty(oEVSKOPF:LFS_NR),
      of gl_EVS_ProzessTyp_Entnahmeschein  :: Result := oEVSSBP:ENTSCH_NR  == oEVSKOPF:ENTSCH_NR and not empty(oEVSKOPF:ENTSCH_NR),
      of gl_EVS_ProzessTyp_Beistellung     :: Result := oEVSSBP:BESTPOSNR == oEVSKOPF:BESTPOSNR and not empty(oEVSKOPF:BESTPOSNR),
   endcase,
end,


//##############################################################################
//##############################################################################
// Funktionen für Entnahmescheine
//##############################################################################
//##############################################################################

//******************************************************************************
// Funktion ermittelt die Sendungs-ID (EVSKOPF:ID), in welcher der
//    Entnahmeschein @cEntnahmeScheinNr enthalten ist
//
// @Result: EVSKOPF:ID / 0 wenn Entnahmeschein noch nicht in einer Sendung erfasst ist
//******************************************************************************
function _EVS_GetSendungsIdForEntnahmeschein(cEntnahmeScheinNr)
   Result := EVS_GetSendungsIdForBeleg(gl_EVS_ProzessTyp_Entnahmeschein, cEntnahmeScheinNr),
end,

//******************************************************************************
// Ermittelt anhand der EntnahmescheinNr die dazugehörige Dab050:ID
//    Bei Sammelentnahmescheinen = erste gefundene AuftragsNr.
// @Result: Dab050:ID
//******************************************************************************
function _EVS_GetDab050_ID_ForEntnahmeschein(cEntschnahmescheinNr)
   | oDAB050_No_Sto_Filter, cFilter |
   Result  := 0,
   oDAB050_No_Sto_Filter                   := BeOpen(waDAB050, 'DAB051'),
   startseq
      oDAB050_No_Sto_Filter.AliasName         := 'DAB050_No_Sto_Filter',
      oDAB050_No_Sto_Filter.UseLocationFilter := 2,                              // Standort-Filter ausschalten
      cFilter := PrepareTextForFTSSearch(waDAB050, 'ENT_LIST', cEntschnahmescheinNr, 'DAB05E', False, False, 'AND', True),
      DBFilter(cFilter, oDAB050_No_Sto_Filter),
      if not NoDs(oDAB050_No_Sto_Filter) then
         Result := oDAB050_No_Sto_Filter:ID,
      endif,
   always
      BeClose(oDAB050_No_Sto_Filter),
   stopseq,
end,

//******************************************************************************
// Ermittelt anhand der EntnahmescheinNr die dazugehörige Kunden-Nr.
// @Result: DAB050:KDNR
//******************************************************************************
function _EVS_GetDab050_KDNR_ForEntnahmeschein(cEntschnahmescheinNr)
   | nID |
   nID      := EVS_GetDab050_ID_ForEntnahmeschein(cEntschnahmescheinNr),
   Result   := LookUp(waDab050, 'ID', {{nID}}, 'KDNR', '',,, -2),                // --> Standort-Filter deaktiviert
end,

//******************************************************************************
// Ermittelt anhand der EntnahmescheinNr die dazugehörige Auftragsnummer
// @Result: DAB050:ANUMMER
//******************************************************************************
function _EVS_GetDab050_ANUMMER_ForEntnahmeschein(cEntschnahmescheinNr)
   | nID |
   nID      := EVS_GetDab050_ID_ForEntnahmeschein(cEntschnahmescheinNr),
   Result   := LookUp(waDab050, 'ID', {{nID}}, 'ANUMMER', '',,, -2),          // --> Standort-Filter deaktiviert
end,

//##############################################################################
//##############################################################################
// Funktionen für Lieferscheine
//##############################################################################
//##############################################################################

//******************************************************************************
// Funktion ermittelt die Sendungs-ID (EVSKOPF:ID), in welcher der
//    Lieferschein @cLieferschein enthalten ist
//
// @Result: EVSKOPF:ID / 0 wenn Lieferschein noch nicht in einer Sendung erfasst ist
//******************************************************************************
function _EVS_GetSendungsIdForLieferschein(cLieferscheinNr)
   Result := EVS_GetSendungsIdForBeleg(gl_EVS_ProzessTyp_Lieferschein, cLieferscheinNr),
end,

//******************************************************************************
// Ermittelt anhand der Lieferschein-Nr. die dazugehörige Auftragsnummer
//    Bei Sammellieferscheinen = erste gefundene AuftragsNr.
// @Result: Dab050:ANUMMER
//******************************************************************************
function _EVS_GetDab050_ANUMMER_ForLieferschein(cLieferscheinNr)
   | oDab020 |
   Result  := '',
   oDab020 := BeOpen(waDAB020, 'DAB025'), // LF_NUMMER;PERSNR
   oDab020.UseLocationFilter := 2,                                              // Location-Filter für Tabelle abstellen, da es sich um Auftrag aus anderem Standort handeln kann
   startseq
      DBScope({cLieferscheinNr}, {cLieferscheinNr}, oDab020),
      DBGoTop(oDab020),
      if not NoDs(oDab020) then
         Result := SubStr(oDab020:APNUMMER, 1, 6),
      endif,
   always
      BeClose(oDab020),
   stopseq,
end,

//******************************************************************************
// Ermittelt anhand der Lieferschein-Nr. die dazugehörige Kunden-Nr.
// @Result: DAB050:KDNR
//******************************************************************************
function _EVS_GetDab050_KDNR_ForLieferschein(cLieferscheinNr)
   | cANUMMER |
   cANUMMER := EVS_GetDab050_ANUMMER_ForLieferschein(cLieferscheinNr),
   Result   := LookUp(waDab050, 'DAB051', {{cANUMMER}}, 'KDNR', 0,,, -2),       // --> Standort-Filter deaktiviert
end,

//******************************************************************************
// Ermittelt anhand der Lieferschein-Nr. die dazugehörige Auftrags-ID
// @Result: DAB050:ID
//******************************************************************************
function _EVS_GetDab050_ID_ForLieferschein(cLieferscheinNr)
   | cANUMMER |
   cANUMMER := EVS_GetDab050_ANUMMER_ForLieferschein(cLieferscheinNr),
   Result   := LookUp(waDab050, 'DAB051', {{cANUMMER}}, 'ID', 0,,, -2),         // --> Standort-Filter deaktiviert
end,

//##############################################################################
//##############################################################################
// Funktionen für Beistellungen (Bestell-Pos.Nr.)
//##############################################################################
//##############################################################################

//******************************************************************************
// Funktion ermittelt die Sendungs-ID (EVSKOPF:ID), in welcher die
//    Bestell-Pos.Nr. @cBestPosNr enthalten ist
//
// @Result: EVSKOPF:ID / 0 wenn Lieferschein noch nicht in einer Sendung erfasst ist
//******************************************************************************
function _EVS_GetSendungsIdForBestPosNr(cBestPosNr)
   Result := EVS_GetSendungsIdForBeleg(gl_EVS_ProzessTyp_Beistellung, cBestPosNr),
end,

//****************************************************************************** // --> TODO: Zusätzlich Validierungen notwendig: Externleistung / Kommiss muss gegeben sein
// Funktion ermittelt Lieferanten-Nr anhand einer übergebenen BestPosNr
//
// @Result: numeric (DAB035:LIEFNR)
//******************************************************************************
function _EVS_GetLiefNrFromBestPosNr(cBestPosNr)
   | oDAB035 |
   Result := 0,
   oDAB035 := BeOpen(waDAB035, 'DAB03B'), // Index: BESTPOSNR;LIEFNR;TERM_INDEX
   startseq
      DBScope({cBestPosNr}, {cBestPosNr}, oDAB035),
      DBGoTop(oDAB035),
      if not NoDs(oDAB035) then
         Result := oDAB035:LIEFNR,
      else
         MessageDlg("Für diese Bestell-Positions-Nr. konnte kein Lieferant/Bestellrückstand ermittelt werden!", mtWarning),
      endif,
   always
      BeClose(oDAB035),
   stopseq,
end,

//******************************************************************************
// Ermittelt aus einer DAB035:KOMMISS die DAB240:B_POS_LFD (ohne Prüfung auf Existenz!)
// @Result: "B_POS_LFD" als String
//******************************************************************************
function _EVS_DAB035_KOMMISS_2_B_POS_LFD(cDab035_KommissNo)
   | cB_POS_LFD, cFAUndSplitNr, nFANummer, nSplitNummer, nLfdNr |

   SetErrorIf(empty(cDab035_KommissNo), 'empty(cDab035_KommissNo)'),

   // zur Info: Format der DAB035:KOMMISS, die auf eine Produktions-Positions "zeigt":
   //      1) bei Nicht-Splitaufträge sieht die KOMMISS z.B: so aus "600086.007".    B_POS_LFD => '600086  007'
   //      2) bei       Splitaufträge sieht die KOMMISS z.B: so aus "600086/01.008". B_POS_LFD => '60008601008'
   //      3) bei FA-Nummernkreis < 6 Stellen                         "5001/01.008". B_POS_LFD => '  500101008'

   cDab035_KommissNo := AllTrim(cDab035_KommissNo),
   cFAUndSplitNr     :=     Token(cDab035_KommissNo, '.', 1),
   nLfdNr            := Val(Token(cDab035_KommissNo, '.', 2)),

   nFANummer         := Val(Token(cFAUndSplitNr,     '/', 1)),
   nSplitNummer      := Val(Token(cFAUndSplitNr,     '/', 2)),

   Result            := PadL(nFANummer, 6) + iif(nSplitNummer = 0, '  ', StrZero(nSplitNummer, 2)) + StrZero(nLfdNr, 3),
end,

//******************************************************************************
// Ermittelt aus einer DAB240:B_POS_LFD die (DAB035/DAB320:)KOMMISS (ohne Prüfung auf Existenz!)
// @Result: "KOMMISS" als String
//******************************************************************************
function _EVS_B_POS_LFD_2_KOMMISS(cB_POS_LFD)
   | cKOMMISS, cFAUndSplitNr, cFANummer, cSplitNummer, nLfdNr |

   SetErrorIf(empty(cB_POS_LFD), 'empty(cB_POS_LFD)'),

   cFAUndSplitNr     := SubStr(cB_POS_LFD, 1, 8),
   nLfdNr            := Val(Right(cB_POS_LFD, 3)),

   cFANummer         := SubStr(cFAUndSplitNr, 1, 6),
   cSplitNummer      := SubStr(cFAUndSplitNr, 7, 8),

   Result            := LTrim(cFANummer) + iif(not empty(cSplitNummer), '/' + cSplitNummer, '') + '.' + StrZero(nLfdNr, 3),
end,

//******************************************************************************
// Funktion wandelt eine DAB020:APNUMMER in das Format einer DAB035:BESTPOSNR
//    Wichtig: Das in der Funktion angegebene Beispiel ist zu beachten, da nicht
//             jede APNUMMER in eine BESTPOSNR umgewandelt werden kann
//             --> Funktioniert für Prod.Aufträge
// @Result: Character (BESTPOSNR)
//******************************************************************************
function _EVS_DAB020_APNUMMER_2_BESTPOSNR(cAPNUMMER)
   | cAnummer, cPos |

   SetErrorIf(empty(cAPNUMMER), 'empty(cAPNUMMER)'),

   // zur Info: Format der DAB020:APNUMMER, die auf eine Produktions-Positions
   //           (DAB035:BESTPOSNR) "zeigt", ist verschieden
   // Beispiel: APNUMMER = '700066 1'  --> BESTPOSNR = '700066  1' (Ein Leerzeichen mehr)

   cAnummer :=         SubStr(cAPNUMMER, 1, 6),
   cPos     := AllTrim(Substr(cAPNUMMER, 7)),
   Result   := AllTrim(cAnummer + PadL(cPos, 2, ' ')),
end,

//******************************************************************************
// Ermittelt Beistell-Informationen anhand der übergebenen @cDab035_KommissNo
// @Result: Array = {B_POS_LFD, ARTNR}
//******************************************************************************
function _EVS_GetBeistellInfosByKommissNo(cDab035_KommissNo)
   | cB_POS_LFD, oDab240 |

   Result     := {},
   cB_POS_LFD := EVS_DAB035_KOMMISS_2_B_POS_LFD(cDab035_KommissNo),

   oDab240 := BeOpen(waDAb240, 'DAB241'),
   startseq
      if DBSeek({cB_POS_LFD}, oDab240) then
         Result := {oDab240:B_POS_LFD, oDab240:ARTNR_E}
      endif,
   always
      BeClose(oDab240),
   stopseq,
end,

//******************************************************************************
// Füllt die Felder für einen neuen Beleg in der ESVSBP-Tabelle
//   - Die übergebene Tabelle @oEVSSBP muss im Insert-Modus sein
//   - Der Datensatz wird nicht gespeichert
//
// @Result: keine Rückgabe
//******************************************************************************
function _EVS_FillInfosForNew_EVSSBP_Beleg(oDM, oEVSKOPF, oEVSSBP, cBelegNr, nPersnr)
   | cKommiss, aAufStkPos |
   SetErrorIf(not DbInTrans(oDM.AdsConnection), 'not DbInTrans(oDM.AdsConnection): transaction must be active on oDM'),
   SetErrorIf(Empty(oEVSKOPF),                   'Empty(oEVSKOPF)'),
   SetErrorIf(DbState(oEVSSBP) <> dsInsert,     'DbState(oEVSSBP) <> dsInsert'),
   SetErrorIf(Empty(cBelegNr),                  'Empty(cBelegNr)'),

   BeginSuspend(oEVSSBP),
   startseq
      case oEVSKOPF:PROZ_TYP
         of gl_EVS_ProzessTyp_Entnahmeschein :: oEVSSBP:ENTSCH_NR := cBelegNr,
            oEVSSBP:KDNR      := nPersnr,
            oEVSSBP:DAB050_ID := EVS_GetDab050_ID_ForEntnahmeschein(cBelegNr),

         of gl_EVS_ProzessTyp_Lieferschein   :: oEVSSBP:LFS_NR    := cBelegNr,
            oEVSSBP:KDNR      := nPersnr,
            oEVSSBP:DAB050_ID := EVS_GetDab050_ID_ForLieferschein(cBelegNr),

         of gl_EVS_ProzessTyp_Beistellung    :: oEVSSBP:BESTPOSNR := cBelegNr,
            oEVSSBP:LINR      := nPersnr,
            cKommiss          := Lookup(waDAB035, 'DAB036', {{oEVSSBP:LINR, oEVSSBP:BESTPOSNR}}, 'KOMMISS', ''),
            aAufStkPos        := EVS_GetBeistellInfosByKommissNo(cKommiss),
            if ALen(aAufStkPos) > 0 then
               oEVSSBP:B_POS_LFD := aAufStkPos[1],
               oEVSSBP:ARTNR_EXL := aAufStkPos[2],
            endif,
      endcase,
   always
      EndSuspend(oEVSSBP),
   stopseq,
end,

//******************************************************************************
// Erzeugt ein Array mit den Adress-Feldern
//******************************************************************************
function _EVS_CustomerOrderData(oTable)
   | cLandnr, nWorkarea, nPersNr, cStaat, cTelefon, oDAB000, oDAB005 |
   Result   := {},
   cLandnr  := "",
   cStaat   := "",
   cTelefon := "",
   // Landnummer für Hauptanschrift
   // Feld LANDNR gibt es im Standard nicht im Auftragskopf
   // daher über asVariant abfragen
   nWorkarea := oTable.Workarea,
   if nWorkarea = 0 and not empty(asvariant("ANUMMER",oTAble)) then
      nWorkarea := waDAB050,
   endif,
   if nWorkarea = waDAB050 then
      oDAB000 := beOpen(waDAB000, 'DF031000'),
      startseq
         cLandnr  := AsVariant("X_LANDNR", oTable),                             // falls es in der DAB050 ein Individualfeld gibt
         if DBSeek({oTable:KDNR}, oDAB000) then
            cLandNr  := E2V(cLandnr, oDAB000:LANDNR),
            cStaat   := E2V(cStaat, oDAB000:X_STAAT),
            cTelefon := RTRim(oDAB000:TELEFON),
            oDAB005 := BeOpen(waDAB005, 'DAB007'),
            startseq
               if DBSeek({oTable:KONTAKT_ID}, oDAB005) then
                  cTelefon := RTRim(E2V(D005_Telefon(oDAB005, oDAB000), cTelefon)),
               endif,
            always
               BeClose(oDAB005),
            stopseq,
         endif,
      always
         BeClose(oDAB000),
      stopseq,
   else,
      cLandnr := e2v(cLandnr,AsVariant("LANDNR", oTable)),
   endif,

   if nWorkarea = waDAB100 then
      nPersNr := oTable:LINR,
   else
      nPersNr := oTable:KDNR,
   endif,

   // aus LS-Anschrift holen
   if nWorkarea <> waDAB100 and not Empty(oTable:LNAME1 + oTable:LNAME2) then
      Result := {nPersNr, oTable:LName1, oTable:LName2, oTable:LName3, oTable:LStrasse, oTable:LPLZORT, oTable:LLANDNR, oTable:VERSENDER, oTable:VERSANDART, oTable:X_FRANKA, cStaat, oTable:KONTAKT, cTelefon},
   endif,
   // was soll passieren, wenn keine Liefer-Anschrift gefunden wurde - dann Hauptadresse ermitteln
   if Alen(Result) = 0 then
      if nWorkarea = waDAB050 then
         Result := {nPersNr, oTable:Name1, oTable:Name2, oTable:Name3, oTable:Strasse, oTable:PLZORT, cLandNr, oTable:VERSENDER, oTable:VERSANDART, oTable:X_FRANKA, cStaat, oTable:KONTAKT, cTelefon},
      else
         Result := {nPersNr, oTable:Name1, oTable:Name2, oTable:Name3, oTable:Strasse, oTable:PLZORT, cLandNr, 1, 1, gl_EVS_FRANKATUR_ZuEigenenLasten, '', '', ''},
      endif,
   endif,
end,

//##############################################################################
//##############################################################################
// Funktionen für Beistell-Stücklisten
//##############################################################################
//##############################################################################

//******************************************************************************
// Prüfung ob die Positionen in der DAB240 vorhanden sind und Rückgabe der DAB240_ID
// Übergeben wird die ProduktionsauftragsNr und das Array mit den Beistellpositionen aus der DAB210
// @Result: Array {DAB240_ID, ArtNr, Abw.Bez., Menge, Typ}
//******************************************************************************
function _EVS_GetEVSBSPPositions240(cB_POS_LFD, aVer_210)
   | oDAB240, nPos, i, nHerstMenge, nTyp |
   Result := {},
   oDAB240 := BeOpen(waDAB240, 'DAB241'), //Index: B_POS_LFD
   startseq
      DBScope({SubStr(cB_POS_LFD, 1, 6)+ '  001'}, {SubStr(cB_POS_LFD, 1, 6) + '  999'}, oDAB240),
      DBGoTop(oDAB240),
      nHerstMenge := Lookup(waDAB240, 'DAB241', {{SubStr(cB_POS_LFD, 1, 6) + '  000'}}, 'SOLL', 1),
      while not Eof(oDAB240) do
         nPos := SeekInDimArray(RTrim(oDAB240:ARTNR_E), aVer_210, 2),
         if nPos <> -1 then
            aAdd(Result, {oDAB240:ID, RTRim(oDAB240:ARTNR_E), aVer_210[nPos, 4], (aVer_210[nPos, 5]/aVer_210[nPos, 7]) * nHerstMenge, aVer_210[nPos, 6], aVer_210[nPos, 8], aVer_210[nPos, 9]}),
         endif,
         DBSkip(1, oDAB240),
      end,

      //Für manuell erfasste Positionen das Array nochmals durchgehen und diese Positionen erfassen
      // Typ = 20
      for i := 1 to Alen(aVer_210) do
         nTyp := aVer_210[i, 6],
         if nTyp = gl_EVS_BSP_TYP_Manuell then
//             aAdd(Result, {0, '', aVer_210[i, 4], (aVer_210[i, 5]/aVer_210[i, 7]) * nHerstMenge, aVer_210[i, 6]}),
            aAdd(Result, {0, '', aVer_210[i, 4], (aVer_210[i, 5]) * nHerstMenge, aVer_210[i, 6], aVer_210[i, 8], aVer_210[i, 9]}),
         endif,
      next,
   always
      BeClose(oDAB240),
   stopseq,
end,

//******************************************************************************
// Mit der Dab210:ID die Beistellpositionen ermitteln
// @Result: Array {VER_210_ID, ArtNr, PosNr, Bez, Menge, Typ}
//******************************************************************************
function _EVS_GetEVSBSPPositions210(nDAB210_ID_E, nDAB240SOLLExt)
   | oEVSBSP, cBez, nMenge, oDAB210, cME, nGEWICHT |
   cME      := '',
   nGEWICHT := 0,
   Result   := {},
   oEVSBSP  := BeOpen(waEVSBSP, 'DAB210_ID'),
   oDAB210  := BeOpen(waDAB210, 'DAB213'),    //Index: ID
   startseq
      DBScope({nDAB210_ID_E}, {nDAB210_ID_E}, oEVSBSP),
      DBGoTop(oEVSBSP),
      while not EoF(oEVSBSP) do
         cBez           := RTrim(oEVSBSP:BEZ),
         nMenge         := oEVSBSP:Menge,
         cME            := oEVSBSP:ME,
         nGEWICHT       := oEVSBSP:GEWICHT,
         if oEVSBSP:TYP = gl_EVS_BSP_TYP_AusStueckliste then
            if DBSeek({oEVSBSP:VER_210_ID}, oDAB210) then
               nMenge   := oDAB210:Menge,
               aAdd(Result, {oEVSBSP:VER_210_ID, oDAB210:ARTNR2, oDAB210:POSNR, cBez, nMenge, oEVSBSP:TYP, nDAB240SOLLExt, cME, nGEWICHT}),
            endif,
         else
            aAdd(Result, {oEVSBSP:VER_210_ID, '', '', cBez, nMenge, oEVSBSP:TYP, nDAB240SOLLExt, cME, nGEWICHT}),
         endif,
         DBSkip(1, oEVSBSP),
      end,
   always
      BeClose(oEVSBSP),
      BeClose(oDAB210),
   stopseq,
end,

//******************************************************************************
// Prüfung ob bereits Beistellpositionen für eine DAB240-ID vorhanden sind
// @Result: true/false
//******************************************************************************
function _EVS_CheckBeistellPositionFromDAB240(nDAB240_ID)
   | oCheckEVSBSP |
   Result := false,
   oCheckEVSBSP := BeOpen(waEVSBSP, 'DAB240_ID'),
   startseq
      DBScope({nDAB240_ID}, {nDAB240_ID}, oCheckEVSBSP),
      Result := NoDs(oCheckEVSBSP),
   always
      BeClose(oCheckEVSBSP),
   stopseq,
end,

//******************************************************************************
// Die Funktion legt einen Datensatz innerhalb der Tabelle EVSBSP mit den
//    übergebenen Variablen an
//
// @Result: null
//******************************************************************************
function _EVS_CreateBeistellPos240(oDM, oEVSBSP, nWorkArea, nID, nVER_240_ID, cArtNr, cAbwBez, nMenge, nTyp, cME, nGewicht)
   BeginSuspend(oEVSBSP),
   startseq,
      DbAppend(oEVSBSP),
      oEVSBSP:DAB240_ID  := nID,
      oEVSBSP:WORKAREA   := nWorkArea,
      oEVSBSP:VER_240_ID := nVER_240_ID,
      oEVSBSP:BEZ        := e2v(cAbwBez, lookup(waDAB010, 'DAB011', {{cArtNr}}, 'BEZ', '')),
      oEVSBSP:MENGE      := nMenge,
      oEVSBSP:TYP        := nTyp,
      oEVSBSP:ME         := cME,
      oEVSBSP:GEWICHT    := nGewicht,
      DbPost(oEVSBSP),
   always
      EndSuspend(oEVSBSP),
   stopseq,
end,

//******************************************************************************
// Funktion: Zum Ermitteln der DAB210:ID aus DAB240-Externleistung
// @Result: null
//******************************************************************************
function _EVS_SetDAB240_BeistellPositionen(oDM, cB_POS_LFD)
   | nRecNo, oEVSBSP, oDAB210, oDAB240, nDAB210ID_E_ArtNr, aVer_210_ID, aVer_240_ID, i |
   oEVSBSP := MyGetTable(oDM, waEVSBSP, 'EVSBSP_WRITE'),
   oDAB240 := BeOpen(waDAB240, 'DAB241'),
   startseq
      oDAB210 := BeOpen(waDAB210, 'DAB211'),   //Index: ARTNR1;POSNR;ARTNR2
      startseq
         aVer_210_ID := {},
         aVer_240_ID := {},
         if DBSeek({cB_POS_LFD}, oDAB240) then
            if oDAB240:ARTTYP = 'E' then
               if EVS_CheckBeistellPositionFromDAB240(oDAB240:ID) then
                  if DBSeek({ RTRim(oDAB240:ARTNR1), RTRim(oDAB240:POSNR)}, oDAB210) then
                     //Die DAB210-ID der Externleistung ermitteln
                     nDAB210ID_E_ArtNr := oDAB210:ID,
                     // Anhand der DAB210_Externleistungs-ID die Beistellpositionen der DAB210 ermitteln
                     aVer_210_ID := EVS_GetEVSBSPPositions210(nDAB210ID_E_ArtNr, oDAB240:SOLL),       //Globale Funktion zur Übernahme der DAB210 - Beistell-Positionen
                     if Alen(aVer_210_ID) > 0 then
                        // Prüfen ob die Beistellpositionen in der DAB240 vorkommen und die ID's zurückgeben
                        // aVer_210_ID = {VER_210_ID, ArtNr, PosNr, Bez, Menge, Typ}
                        aVer_240_ID := EVS_GetEVSBSPPositions240(oDAB240:B_POS_LFD, aVer_210_ID),  //globale Funktion zur ermittelung der VER_240_ID + Menge + manuelle Position
                     endif,

                     if Alen(aVer_240_ID) > 0 then
                        for i := 1 to Alen(aVer_240_ID) do
                            // Erstellen der DAB240 Beistellpositionen aus den DAB210 Beistellpositionen
                            // aVer_240_ID = {VER_240_ID, ArtNr, Abw.Bez., Menge, Typ}
                           EVS_CreateBeistellPos240(oDM, oEVSBSP, waDAB240, oDAB240:ID, aVer_240_ID[i, 1], aVer_240_ID[i, 2], aVer_240_ID[i, 3], aVer_240_ID[i, 4], aVer_240_ID[i, 5], aVer_240_ID[i, 6], aVer_240_ID[i, 7]),
                        next,
                     endif,
                  endif,
               endif,
            endif,
         endif,
      always
         BeClose(oDAB210),
      stopseq,
   always
      BeClose(oDAB240),
   stopseq,
end,


