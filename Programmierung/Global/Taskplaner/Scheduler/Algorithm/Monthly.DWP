function _TSKPL_CalculateStart_Monthly(aTaskExecutionOptions)
| m_aMonthSpecialBounds, m_aRequirements |

   //Konstant
   m_aMonthSpecialBounds := {{0, 20}},


   //***************************************************************************
   // Berechnet das Datum das Datum des Monatsanfangs
   // @Param: DateTime
   // @Result: DateTime, nächster Start
   //***************************************************************************
   function GetNextStartForFirstDayOfMonth(dtLastStart, nDayOfMonth, dtStartFirst, dtTime)
   | dtNextStart |
      dtNextStart := Int(BoM(dtLastStart) + nDayofMonth) + Frac(dtTime),
      // Prüfen, ob ein Start im selben Monat noch zulässig ist.
      if ((dtNextStart > dtStartFirst) or CompareDates(dtNextStart, dtStartFirst)) 
         and ((dtNextStart > dtLastStart) or CompareDates(dtNextStart, dtLastStart)) then
         // Dann geben wir hier den ersten des aktuellen Monats zurück
         result := dtNextStart,
      else
         result := Int(BoM(AddMonth(dtNextStart, 1)) + nDayofMonth) + Frac(dtTime),
      endif,
   end,

   //***************************************************************************
   // Berechnet das Datum der Monatsendes
   // @Param: DateTime
   // @Result: DateTime, nächster Start
   //***************************************************************************
   function GetNextStartForLastDayOfMonth(dtLastStart, nDayOfMonth,  dtStartFirst, dtTime)
   | dtNextStart |
      dtNextStart := Int(EoM(dtLastStart) - nDayofMonth) + Frac(dtTime),
      if (dtNextStart > dtStartFirst) or CompareDates(dtNextStart, dtStartFirst)  
         and ((dtNextStart > dtLastStart) or CompareDates(dtNextStart, dtLastStart)) then
         result := dtNextStart,
      else
         result := Int(EoM(AddMonth(dtNextStart, 1)) - nDayOfMonth) + Frac(dtTime),
      endif,
   end,

   //***************************************************************************
   // Berechnet das Datum x Tage nach Monatsbeginn/vor Monatsende.
   // Liegt das errechnete Datum hinter dem Start, wird auf den nächsten
   // Monat verschoben
   // @Param: DateTime, Numeric, Numeric [100/-100]
   // @Result: DateTime, nächster Start
   //***************************************************************************
   function GetNextStartWithMonthSpecial(dtLastStart, nDayOfMonth, cMonthSpecial, dtStartFirst, dtTime)
   | dtNewStartDate |

      case cMonthSpecial
         of gl_TSKPL_Algorithm_MonthSpecialType_BoM            :: dtNewStartDate := GetNextStartForFirstDayOfMonth(dtLastStart, 0, dtStartFirst, dtTime),
         of gl_TSKPL_Algorithm_MonthSpecialType_EoM            :: dtNewStartDate := GetNextStartForLastDayOfMonth(dtLastStart, 0, dtStartFirst, dtTime),
         of gl_TSKPL_Algorithm_MonthSpecialType_BoM_WithOffset :: dtNewStartDate := GetNextStartForFirstDayOfMonth(dtLastStart, nDayOfMonth - 1, dtStartFirst, dtTime),
         of gl_TSKPL_Algorithm_MonthSpecialType_EoM_WithOffset :: dtNewStartDate := GetNextStartForLastDayOfMonth(dtLastStart, nDayOfMonth, dtStartFirst, dtTime),
      otherwise
         dtNewStartDate := AddMonth(dtLastStart, 1),
      endcase,

      result := ConvertArrayToDateTime(ConvertDateTimeToArray(dtNewStartDate)),
   end,

   //***************************************************************************
   // Prüft, ob die Grenzen für x Tage nach Monatsbeginn/vor Monatsende eingehalten
   // wurden. Soll verhindern, dass sich extreme Verschiebungen in den Monats-
   // bereichen bilden.
   // @Param: Numeric
   // @Result: Boolean
   //***************************************************************************
   function CheckMonthSpecialBounds(nDayOfMonth)
      result := (nDayOfMonth >= m_aMonthSpecialBounds[1, 1]) and
                (nDayOfMonth <= m_aMonthSpecialBounds[1, 2]),
   end,

   //***************************************************************************
   // Prüft, ob alle Anforderungen für den Auführzeitplan übergeben wurden
   // @Param: Array mit Ausführoptionen
   // @Result: boolean, findet aber keine Verwendung, da SetError abbricht
   //***************************************************************************
   function CheckRequirements(aTaskExecutionOptions, aRequirements:R)
   | i, cOutput, localReq, cKey |
      //Wir gehen davon aus, dass alles passt und missbrauchen result dafür
      result  := True,
      cOutput := '',
      if (ALen(aTaskExecutionOptions) < 1) then
         SetError('Keine Zeitplan-Optionen!'),
      endif,
      localReq := aRequirements,
      for i := 1 to ALen(localReq) do
         cKey := localReq[i],
         if KVU_FIND(aTaskExecutionOptions, cKey) < 0 then
            cOutput := cOutput + ' ' + cKey,
            result := False,
         endif,
      end,
      if not result then
         SetError('Anforderungen fehlen: ' + cOutput),
      endif,
   end,

   //***************************************************************************
   // Von außen einzig aufrufbare Funktion (PSEUDO), da default
   // @Param: Array mit Ausführoptionen
   // @Result: DateTime
   //***************************************************************************
   function GetNextStartForTask(aTaskExecutionOptions)
   |
      dtLastStart, nDayOfMonth, cMonthSpecial, dtTime, nHours, nMinutes, nSeconds,
      nMilli, aLastStart, dtStartFirst, dtNow
   |

      if (ALen(aTaskExecutionOptions) < 1) then
         SetError('Keine Zeitplan-Optionen!'),
      endif,

      dtNow        := GetAdsServerTime(),
      dtStartFirst := KVU_GET(aTaskExecutionOptions, 'execution.StartFirst', dtNow),
      if dtStartFirst < dtNow then
        dtStartFirst := dtNow,
      endif,
      aLastStart   := KVU_GETAssert(aTaskExecutionOptions, 'execution.LastStart'),
      dtLastStart  := ConvertArrayToDateTime(aLastStart),
      dtLastStart  := iif(Empty(dtLastStart), dtStartFirst, dtLastStart),

      nDayOfMonth   := KVU_GET(aTaskExecutionOptions, 'execution.DayOfMonth', 1),
      cMonthSpecial := KVU_GetAssert(aTaskExecutionOptions, 'execution.MonthSpecial'),
      dtTime        := KVU_GET(aTaskExecutionOptions, 'execution.Time', EncodeTime(0, 1, 0, 0)),

      DecodeTime(dtTime, nHours, nMinutes, nSeconds, nMilli),
      dtTime := EncodeTime(nHours, nMinutes, 0, 0),

      SetErrorIf(
         Empty(cMonthSpecial) and not CheckMonthSpecialBounds(nDayOfMonth),
         'Tage (nach Monatsbeginn/vor Monatsende) verletzt Grenzen [' +
            Str(m_aMonthSpecialBounds[1, 1]) + ', ' +
            Str(m_aMonthSpecialBounds[1, 2]) + ']'
      ),
      result := GetNextStartWithMonthSpecial(dtLastStart, nDayOfMonth, cMonthSpecial, dtStartFirst, dtTime),
   end,

   //Requirements definieren
   m_aRequirements := Dim(0),
   m_aRequirements := {'execution.DayOfMonth', 'execution.MonthSpecial',
                       'execution.Time'},

   CheckRequirements(aTaskExecutionOptions, m_aRequirements),

   result := GetNextStartForTask(aTaskExecutionOptions),
end,

