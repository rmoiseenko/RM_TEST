function _TSKPL_CalculateStart_Yearly(aTaskExecutionOptions)
| m_aMonthBounds, m_aDayBounds, m_aRequirements, m_dtStartTime,
  m_dtCalcBase |

   //Konstant
   m_aMonthBounds := {{1, 12}},
   m_aDayBounds   := {{1, 31}},

   //******************************************************************************
   // Prüft ob die Monatsangabe innerhalb gültiger Grenzen ist
   // @Param: Numeric
   // @Result: Boolean
   //******************************************************************************
   function CheckMonthBounds(nMonth)
      result := ( (nMonth >= m_aMonthBounds[1, 1]) and
                  (nMonth < m_aMonthBounds[1, 2])),
   end,

   //******************************************************************************
   // Prüft ob die Tagangabe innerhalb gültiger Grenzen ist
   // @Param: Numeric
   // @Result: Boolean
   //******************************************************************************
   function CheckDayBounds(nDay)
      result := ( (nDay >= m_aDayBounds[1, 1]) and
                  (nDay <= m_aDayBounds[1, 2])),
   end,

   //******************************************************************************
   // Berechnet den Startzeitpunkt für jährliche Ausführung
   // @Param: Numeric [1-12], Numeric [1-31]
   // @Result: DateTime, nächster Start
   //******************************************************************************
   function CalculateNextStartDate(nMonth, nDay)
   | dtNewDate |

      //Prüfen, ob Werte in gültigen Bereichen liegen
      if !(checkMonthBounds(nMonth)) then
         SetError('Monat verletzt Grenzen [' +
               Str(m_aMonthBounds[1, 1]) + ', ' +
               Str(m_aMonthBounds[1, 2]) + ']'),
      endif,

      if !(checkDayBounds(nDay)) then
         SetError('Tag verletzt Grenzen [' +
               Str(m_aDayBounds[1, 1]) + ', ' +
               Str(m_aDayBounds[1, 2]) + ']'),
      endif,

      //Februar-Check
      if ( (nMonth = 2) and (nDay > 28) ) then
         if (isLeapYear(Year(m_dtCalcBase)+1)) then
            nDay := 29,
         else
            nDay := 28,
         endif,
      endif,

      dtNewDate := EncodeDate(Year(m_dtCalcBase), nMonth, nDay),
      if (dtNewDate > m_dtCalcBase) then
         result := dtNewDate,
      else
         result := AddMonth(dtNewDate, 12),
      endif,
   
   end,

   //***************************************************************************
   // Prüft, ob alle Anforderungen für den Auführzeitplan übergeben wurden
   // @Param: Array mit Ausführoptionen
   // @Result: boolean, findet aber keine Verwendung, da SetError abbricht
   //***************************************************************************
   function CheckRequirements(aTaskExecutionOptions, aRequirements:R)
   | i, cOutput, localReq, cKey |
      //Wir gehen davon aus, dass alles passt und missbrauchen result dafür
      result := True,
      cOutput := '',
      if (ALen(aTaskExecutionOptions) < 1) then
         SetError('Keine Zeitplan-Optionen!'),
      endif,
      localReq := aRequirements,
      for i := 1 to ALen(localReq) do
         cKey := localReq[i],
         if KVU_FIND(aTaskExecutionOptions, cKey) < 0 then
            cOutput := cOutput + ' ' + cKey,
            result := False,
         endif,
      end,
      if not result then
         SetError('Anforderungen fehlen: ' + cOutput),
      endif,
   end,

   //***************************************************************************
   // Extrahiert die Zeit vom übergebenen Datum
   // @Param: DateTime, Numeric
   // @Result: DateTime
   //***************************************************************************
   function GetTimeFromDateTime(dtDateTime)
      | nHours, nMinutes, nSeconds, nMilli |
         DecodeTime(dtDateTime, nHours, nMinutes, nSeconds, nMilli),
         result := EncodeTime(nHours, nMinutes, nSeconds, nMilli),
   end,

   //***************************************************************************
   // Von außen einzig aufrufbare Funktion (PSEUDO), da default
   // @Param: Array mit Ausführoptionen
   // @Result: DateTime
   //***************************************************************************
   function GetNextStartForTask(aTaskExecutionOptions)
   | nStartMonth, nStartDay, dtStartTime, nHours, nMinutes, nSeconds, nMilli,
     nDay, nMonth, nYear, dtTimeNow, bDateIsCalculated, dtCalcBase, dtNow |

      if (ALen(aTaskExecutionOptions) < 1) then
         SetError('Keine Zeitplan-Optionen!'),
      endif,

      dtStartTime  := KVU_GET(aTaskExecutionOptions, 'execution.Time', '12:00'),
      nStartMonth  := KVU_GET(aTaskExecutionOptions, 'execution.Month', 1),
      nStartDay    := KVU_GET(aTaskExecutionOptions, 'execution.Day', 1),
      dtCalcBase   := KVU_GET(aTaskExecutionOptions, 'execution.CalcBase', GetAdsServerTime()),
      if dtCalcBase < dtNow then
        dtCalcBase := dtNow,
      endif,
      m_dtCalcBase := dtCalcBase,

      //Zeit extrahieren
      DecodeTime(dtStartTime, nHours, nMinutes, nSeconds, nMilli),
      dtStartTime := EncodeTime(nHours, nMinutes, 0, 0),

      //Datum extrahieren
      DecodeDate(m_dtCalcBase, nYear, nMonth, nDay),

      bDateIsCalculated := False,

      if (nStartMonth = nMonth) and (nStartDay = nDay) then
        //selber Tag.
        //Klappt das von der Zeit noch?
        dtTimeNow := GetTimeFromDateTime(m_dtCalcBase),
        if dtStartTime > dtTimeNow then
           result := m_dtCalcBase - GetTimeFromDateTime(m_dtCalcBase),
           bDateIsCalculated := True,
        endif,
      endif,

      if not bDateIsCalculated then
         result := CalculateNextStartDate(nStartMonth, nStartDay),
      endif,
      
      //Zeit aufrechnen
      result := result + dtStartTime,
   end,

   //Requirements definieren
   m_aRequirements := Dim(0),
   m_aRequirements := {'execution.Month', 'execution.Day',
                       'execution.Time'},

   CheckRequirements(aTaskExecutionOptions, m_aRequirements),

   result := GetNextStartForTask(aTaskExecutionOptions),
end,
