//##############################################################################
//##############################################################################
// Beschreibung:
//   Funktionen zum Traversieren, Lesen und Schreiben des "abstract syntax tree".
//
// Die Abkürzung "AST" steht für "abstract syntax tree".
//##############################################################################
//##############################################################################

function _EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTree:O) ... end,

//##############################################################################
//##############################################################################
// Funktionen (Read)
//##############################################################################
//##############################################################################

//******************************************************************************
// Diese Funktion ermittelt in der aktuellen Ebene den am nächsten gelegenen
// Segmentknoten (ein-schließlich des aktuellen Knoten), welcher dem dem
// übergebenen Segment-Bezeichner entspricht.
//
// @result: object - TTreeNodeEx
//******************************************************************************
function _EDI_Edifact_AST_FindNearest(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C)
| oNode, cExpectedClassName |

   cExpectedClassName := 'TTreeNodeEx',
   SetErrorIf(
      not ClassOf(oAbstractSyntaxTreeNode, cExpectedClassName),
      'Given parameter <oAbstractSyntaxTreeNode> must be of type <' + cExpectedClassName + '>'
   ),

   result := nil,
   oNode  := oAbstractSyntaxTreeNode,

   while not empty(oNode) do
      prs('cSegmentIdentifier', {cSegmentIdentifier}),
      prs('NextSibling', {oNode.NextSibling}),
      prs('oNode Text', {oNode.Text}),

//      prs('Value', {oNode.Value}),
      prs('', {'----'}),

      if Left(oNode.Text, ALen(cSegmentIdentifier)) == cSegmentIdentifier then
         result := oNode,
         break,
      endif,

      if empty(oNode.NextSibling) then
         break,
      endif,

      oNode := oNode.NextSibling,
   end,
end,

//******************************************************************************
// Diese Funktion sucht in der aktuellen Ebene vom übergebenen Knoten aus nach
// allen Segmentknoten, welche mit dem übergebenen Segment-Bezeichner
// übereinstimmen.
//
// @result: array - Liste der gefundenen Segmente
//******************************************************************************
function _EDI_Edifact_AST_FindAll(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C)
| oNode |

   result := {},
   oNode  := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTreeNode),
   oNode  := EDI_Edifact_AST_FindNearest(oNode, cSegmentIdentifier),
   while not empty(oNode) do
      AAdd(result, oNode),
      oNode := EDI_Edifact_AST_FindNearest(oNode.NextSibling, cSegmentIdentifier),
   end,
end,

//******************************************************************************
// Diese Funktion sucht rekursiv nach allen Segmenten mit dem übergebenen
// Segment-Bezeichner.
//
// @result: array - Liste der gefundenen Segmente
//******************************************************************************
function _EDI_Edifact_AST_FindAllRecursive(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C)
| oMainNode |

   function FindSegment(oNode:O, cSegmentIdentifier:C, aSegments:R, nLevel:N:=0)
      if Left(oNode.Text, Len(cSegmentIdentifier)) == cSegmentIdentifier then
         AAdd(aSegments, oNode),
      endif,
      // Erst alle untergeordneten Knoten verarbeiten
      if oNode.HasChildren then
         FindSegment(oNode.FirstChild, cSegmentIdentifier, aSegments, nLevel + 1),
      endif,
      // Nächsten Geschwister-Knoten verarbeiten
      if not empty(oNode.NextSibling) then
         FindSegment(oNode.NextSibling, cSegmentIdentifier, aSegments, nLevel),
      endif,
   end,

   result    := {},
   oMainNode := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTreeNode),

   if not empty(oMainNode) then
      FindSegment(oMainNode, cSegmentIdentifier, result),
   endif,
end,

//******************************************************************************
// Diese Funktion sucht rekursiv nach allen Segmenten mit dem übergebenen
// Segment-Bezeichner innerhalb (!) des übergebenen Segmentnodes
//
// @result: array - Liste der gefundenen Segmente
//******************************************************************************
function _EDI_Edifact_AST_FindAllRecursive_Internal(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C)
| oMainNode |

   function FindSegment(oNode:O, cSegmentIdentifier:C, aSegments:R, bInit:B:=true, nLevel:N:=0)
   | cOriginalSegmentIdentifier, cCurrentSegmentIdentifier, bCancel |

      bCancel := false,
      cCurrentSegmentIdentifier := Left(oNode.Text, Len(cSegmentIdentifier)),

      if bInit then
         cOriginalSegmentIdentifier := '',
         cOriginalSegmentIdentifier := cCurrentSegmentIdentifier,
      endif,

      if not bInit and
         not empty(cOriginalSegmentIdentifier) and
         cOriginalSegmentIdentifier == cCurrentSegmentIdentifier then

         cOriginalSegmentIdentifier := '',
         bCancel := true,
      endif,

      if not bCancel then
         if cCurrentSegmentIdentifier == cSegmentIdentifier then
            AAdd(aSegments, oNode),
         endif,
         // Erst alle untergeordneten Knoten verarbeiten
         if oNode.HasChildren then
            FindSegment(oNode.FirstChild, cSegmentIdentifier, aSegments, false, nLevel + 1),
         endif,
         // Nächsten Geschwister-Knoten verarbeiten
         if not empty(oNode.NextSibling) then
            FindSegment(oNode.NextSibling, cSegmentIdentifier, aSegments, false, nLevel),
         endif,
      endif,
   end,

   result := {},
   oMainNode := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTreeNode),

   if not empty(oMainNode) then
      FindSegment(oMainNode, cSegmentIdentifier, result),
   endif,
end,

//******************************************************************************
// Diese Funktion ermittelt das nächstgelegene Segment mit dem übergebenen
// Segment-Bezeichner in der untergeordneten Ebene des aktuellen Knotens.
//
// @result: object - TTreeNodeEx
//******************************************************************************
function _EDI_Edifact_AST_FindChild(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C)
| oNode |

   oNode := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTreeNode),
   if oNode.HasChildren then
      result := EDI_Edifact_AST_FindNearest(oNode.FirstChild, cSegmentIdentifier),
   else
      result := nil,
   endif,
end,

//******************************************************************************
// Diese Funktion ermittelt alle Segmentknoten mit dem übergebenen
// Segmentbezeichner in der untergeordneten Ebene.
//
// @result: array
//******************************************************************************
function _EDI_Edifact_AST_FindChildren(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C)
| oNode |

   result := {},
   oNode  := EDI_Edifact_AST_FindChild(oAbstractSyntaxTreeNode, cSegmentIdentifier),
   while not empty(oNode) do
      AAdd(result, oNode),
      oNode := EDI_Edifact_AST_FindNearest(oNode.NextSibling, cSegmentIdentifier),
   end,
end,

//******************************************************************************
// Diese Funktion ermittelt anhand des übergebenen EDI-Segmentpfads das
// entsprechende Segment-Objekt und gibt dieses zurück.
//
// Der Segmentpfad bezieht sich dabei immer auf die Kind-Knoten des übergebenen
// Referenzknotens (oReferenceNode).
//
// Beispiele:
//
//   | Referenzknoten | Segmentpfad | Voller Segmentpfad       |
//   ----------------------------------------------------------|
//   | ROOT           | "UNB"       | ROOT/UNB                 |
//   | SG25           | "SG28/PRI"  | ROOT/SGMSG/SG25/SG28/PRI |
//
// @result: object - TTreeNodeEx
//******************************************************************************
function _EDI_Edifact_AST_FindPath(oReferenceNode:O, cSegmentPath:C)
|
   oNode, nPathItems, cSegmentIdentifier, i,
   nPosIndexOpen, nPosIndexClose, cSegmentIndexString, nSegmentIndex
|

   result := nil,
   oNode  := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oReferenceNode),

   SetErrorIf(not oNode.HasChildren, 'No child nodes available in reference node'),
   oNode := oNode.FirstChild,

   nPathItems := TokenCount(cSegmentPath, '/'),
   for i := 1 to nPathItems do
      cSegmentIdentifier := Token(cSegmentPath, '/', i),
      // Segment-Identifier validieren:
      //   Segment-Identifier dürfen nicht leer sein. Das bedeutet auch, dass
      //   die Angabe eines Segmentpfads wie z.B. "/SGMSG/SG25/LIN" ungültig
      //   ist, weil vor dem ersten Slash ("/") kein Segment angegeben wurde.
      //
      // Beispiele für leere Segement-Identifier in Segmentpfaden:
      //   "/SGMSG/SG25/LIN"  => leeres Segment am Anfang
      //   "SGMSG/SG25/SG28/" => leeres Segment am Ende
      //   "/SGMSG//SG25/LIN" => leeres Segment zwischen "SGMSG" und "SG25"
      SetErrorIf(
         empty(AllTrim(cSegmentIdentifier)),
         'Empty segment identifier is not allowed (index: ' + str(i) + ' in path "' + cSegmentPath + '")'
      ),

      nPosIndexOpen  := RAt('[', cSegmentIdentifier),
      nPosIndexClose := RAt(']', cSegmentIdentifier),
      nSegmentIndex  := 1,
      if nPosIndexOpen > 0 and nPosIndexClose > 0 then
         cSegmentIndexString := SubStr(cSegmentIdentifier, nPosIndexOpen + 1, Len(cSegmentIdentifier) - nPosIndexOpen - 1),
         nSegmentIndex       := val(cSegmentIndexString),
         cSegmentIdentifier  := left(cSegmentIdentifier, nPosIndexOpen - 1),
      endif,

      while nSegmentIndex > 0 do
         if not empty(oNode) then
            oNode := EDI_Edifact_AST_FindNearest(oNode, cSegmentIdentifier),
         endif,

         if not (empty(oNode) and 'SG' $ cSegmentPath) then
            SetErrorIf(empty(oNode), 'Segment "' + cSegmentIdentifier + '" not present in current scope'),

            nSegmentIndex--,
            if nSegmentIndex > 0 then
               oNode := oNode.NextSibling,
            endif,
         else
            exit,
         endif,
      end,

      if i = nPathItems then
         result := oNode,
      else
         oNode := oNode.FirstChild,
      endif,
   next,
end,

//******************************************************************************
// Diese Funktion lest den Wert mit dem übergebenen Datenelement-Bezeichner aus
// dem übergebenen Segment aus und gibt diesen zurück.
//
// @result: string - Wert des Segments
//******************************************************************************
function _EDI_Edifact_AST_GetValue(oAbstractSyntaxTreeNode:O,
                           cCompositeDataElementIdentifier:C,
                           cDataElementIdentifier:C:='')
|
   oEDISEGM, aPositionInfo, cSegment,
   nStandard, cElementSeperator, cCompositeElementSeperator, i
|

   // TODO: Alle Infos in den AST "verpacken", damit diese nicht global sind

   result                     := '',
   nStandard                  := EDI_Edifact_Context_GetStandard(),
   cElementSeperator          := EDI_Edifact_Context_GetElementSeperator(),
   cCompositeElementSeperator := EDI_Edifact_Context_GetCompositeElementSeperator(),

   cSegment := oAbstractSyntaxTreeNode.Text,
   oEDISEGM := BeOpen(waEDISEGM, 'INDEX_UNIQUE'),
   startseq
      aPositionInfo := EDI_Edifact_SegmentMapping_GetPosition(
         oEDISEGM,
         nStandard,
         EDI_Edifact_SegmentString_ExtractSegmentIdentifier_Internal(cSegment, cElementSeperator),
         cCompositeDataElementIdentifier,
         cDataElementIdentifier
      ),
   always
      BeClose(oEDISEGM),
   stopseq,
   for i := 1 to ALen(aPositionInfo) do
      result := result + EDI_Edifact_SegmentString_ExtractValue_Internal(
         cSegment,
         aPositionInfo[i],
         cElementSeperator,
         cCompositeElementSeperator
      ),
   next,
end,

//******************************************************************************
//
// @result: string - Wert des Segments
//******************************************************************************
function _EDI_Edifact_AST_GetPathValue(oAbstractSyntaxTreeNode:O,
                               cSegmentPath:C,
                               cCompositeDataElementIdentifier:C,
                               cDataElementIdentifier:C:='')
| oSegmentNode |
   result := '',
   oSegmentNode := EDI_Edifact_AST_FindPath(oAbstractSyntaxTreeNode, cSegmentPath),
   if not empty(oSegmentNode) then
      result := EDI_Edifact_AST_GetValue(oSegmentNode, cCompositeDataElementIdentifier, cDataElementIdentifier),
   endif,
end,

//##############################################################################
//##############################################################################
// Funktionen (Write)
//##############################################################################
//##############################################################################

//******************************************************************************
// Diese Funktion fügt dem übergebenen AST-Node einen neuen Child-node hinzu mit
// dem Segment als String.
//
// @result: object - TTreeNodeEx
//******************************************************************************
function _EDI_Edifact_AST_AddSegmentAsString(oAbstractSyntaxTreeNode:O, cSegmentString:C)
| oNode |

   oNode       := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTreeNode),
   result      := oNode.AddChild,
   result.text := cSegmentString,
end,

//******************************************************************************
// Diese Funktion fügt dem übergebenen AST-Node einen neuen Child-node hinzu mit
// dem Segment im Array-Format.
//
// @result: object - TTreeNodeEx
//******************************************************************************
function _EDI_Edifact_AST_AddSegment(oAbstractSyntaxTreeNode:O, cSegmentIdentifier:C, aSegmentContent:A)
| cSegmentString |

   //***************************************************************************
   function AppendElementsToSegmentString(aElements:A, bIsCompositeElement:L)
   | i, cDelimiter, uItem |

      if bIsCompositeElement then
         cDelimiter := gl_EDI_Default_CompositeElementSeperator,
      else
         cDelimiter := gl_EDI_Default_ElementSeperator,
      endif,

      for i := 1 to ALen(aElements) do
         uItem := aElements[i],
         if not bIsCompositeElement or i > 1 then
            cSegmentString += cDelimiter,
         endif,
         if ValType(uItem) == 'A' then
            AppendElementsToSegmentString(uItem, true),
         else
            cSegmentString += ToString(uItem),
         endif,
      next,
   end,

   cSegmentString := cSegmentIdentifier,
   AppendElementsToSegmentString(aSegmentContent, false),
   cSegmentString += gl_EDI_Default_SegmentTerminator,

   result := EDI_Edifact_AST_AddSegmentAsString(oAbstractSyntaxTreeNode, cSegmentString),
end,

//******************************************************************************
// Diese Funktion fügt dem übergebenen AST-Node das UNA-Segemnt hinzu.
// @result: object - TTreeNodeEx
//******************************************************************************
function _EDI_Edifact_AST_AddUNASegment(oAbstractSyntaxTreeNode:O)
   // Standard UNA-Segment: UNA:+.? '
   result := EDI_Edifact_AST_AddSegmentAsString(
      oAbstractSyntaxTreeNode,
      'UNA' +
      gl_EDI_Default_CompositeElementSeperator +
      gl_EDI_Default_ElementSeperator +
      gl_EDI_Default_DecimalSeperator +
      gl_EDI_Default_ReleaseIndicator +
      gl_EDI_Default_ReservedCharacter +
      gl_EDI_Default_SegmentTerminator
   ),
end,

//******************************************************************************
// Diese Funktion erzeugt einen EDIFACT-Nachrichten-String anhand eines
// "abstract syntax tree" (AST).
//
// @result: string - EDIFACT-Nachricht
//******************************************************************************
function _EDI_Edifact_AST_ComposeMessage(oAST:O)
| oFirstNode, nMessagesCount, nSegmentsCount |

   //***************************************************************************
   function ComposeMessage_Internal(oNode:O, nMessagesCount:R, nSegmentsCount:R)
   | cSegmentString, oChildNode |

      result := '',

      if oNode.HasChildren then
         oChildNode := oNode.FirstChild,
         while not empty(oChildNode) do
            result := ConcatTrenner(result, ComposeMessage_Internal(oChildNode, nMessagesCount, nSegmentsCount), CRLF),
            oChildNode := oChildNode.NextSibling,
         end,
      else
         cSegmentString := oNode.Text,
         case EDI_Edifact_SegmentString_ExtractSegmentIdentifier_Internal(cSegmentString, gl_EDI_Default_ElementSeperator)
            of 'UNH' ::
               nSegmentsCount := 1 // Segment-Zähler initialisieren

            of 'UNT' ::
               nSegmentsCount++,
               cSegmentString := EDI_Edifact_SegmentString_SetValue_Internal(
                  cSegmentString,
                  EDI_Edifact_DataElementMap_Create(1, 0, true, false),
                  nSegmentsCount,
                  gl_EDI_Default_ElementSeperator,
                  gl_EDI_Default_CompositeElementSeperator,
                  gl_EDI_Default_SegmentTerminator
               ),

               nMessagesCount++,
               nSegmentsCount := -1,

            of 'UNZ' ::
               cSegmentString := EDI_Edifact_SegmentString_SetValue_Internal(
                  cSegmentString,
                  EDI_Edifact_DataElementMap_Create(1, 0, true, false),
                  nMessagesCount,
                  gl_EDI_Default_ElementSeperator,
                  gl_EDI_Default_CompositeElementSeperator,
                  gl_EDI_Default_SegmentTerminator
               ),

            otherwise
               if nSegmentsCount <> -1 then
                  nSegmentsCount++,
               endif,
         endcase,

         result := cSegmentString,
      endif,
   end,

   result := '',

   nMessagesCount := 0,
   nSegmentsCount := -1,

   oFirstNode := EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAST),

   result := ComposeMessage_Internal(oFirstNode, nMessagesCount, nSegmentsCount),
end,

//******************************************************************************
// Diese Funktion visualisiert den aktuellen Zustand des abstrakten Syntaxbaums.
// @result: null - keine Rückgabe
//******************************************************************************
function _EDI_Edifact_AST_DebugGUI(oAbstractSyntaxTree:O)
   oAbstractSyntaxTree.Align := alClient,
   ShowModal(GetOwner(oAbstractSyntaxTree)),
end,

//******************************************************************************
// Diese Funktion erzeugt einen String, welcher den aktuellen Zustand des
// abstrakten Syntaxbaums repräsentiert.
//
// @result: string - Abstrakter Syntaxbaum als String
//******************************************************************************
function _EDI_Edifact_AST_DebugString(oAbstractSyntaxTree:O)
| oMainNode |

   function ProcessNode(oNode:O, nLevel:N:=0)
      result := Replicate('   ', nLevel) + oNode.Text + iif(empty(oNode.Value), '', ': ' + oNode.Value) + CRLF,
      // Erst alle untergeordneten Knoten verarbeiten
      if oNode.HasChildren then
         result += ProcessNode(oNode.FirstChild, nLevel + 1),
      endif,
      // Nächsten Geschwister-Knoten verarbeiten
      if not empty(oNode.NextSibling) then
         result += ProcessNode(oNode.NextSibling, nLevel),
      endif,
   end,

   oMainNode := oAbstractSyntaxTree.FirstNode,
   if empty(oMainNode) then
      result := '',
   else
      result := ProcessNode(oMainNode),
   endif,
end,

//******************************************************************************
// Diese Funktion erzeugt das Hauptobjekt für den abstrakten Syntaxbaum einer
// EDI-Nachricht.
//
// @result: object - TTreeViewEx
//******************************************************************************
function _EDI_Edifact_AST_Create(oOwnerForm:O:=nil)
| bOwnerFormProvided |

   bOwnerFormProvided := not empty(oOwnerForm),
   SetErrorIf(
      bOwnerFormProvided and not ClassOf(oOwnerForm, 'TForm'),
      'Provided parameter oOwnerForm must be of class <TForm> or any of its derivations'
   ),

   // HINWEIS:
   //   Das TTreeViewEx-Objekt braucht immer ein übergeordnetes Fenster um neue
   //   Unterknoten anfügen zu können.

   if not bOwnerFormProvided then
      oOwnerForm := CreateObject('TFormEx'),
   endif,
   startseq
      result := CreateObject('TTreeViewEx', '', oOwnerForm, oOwnerForm),
   onerror
      if not bOwnerFormProvided then
         DestroyObject(oOwnerForm),
      endif,
      Raise(),
   stopseq,
end,

//******************************************************************************
// Diese Funktion zerstört den übergebenen abstrakten Syntaxbaum.
// @result: null - keine Rückgabe
//******************************************************************************
function _EDI_Edifact_AST_Destroy(oAbstractSyntaxTree:R)
| oOwner |

   oOwner := GetOwner(oAbstractSyntaxTree),
   if empty(oOwner) then
      DestroyObject(oAbstractSyntaxTree),
   else
      DestroyObject(oOwner),
   endif,

   oAbstractSyntaxTree := nil,
end,

//******************************************************************************
// Diese Funktion übersetzt den Text der EDI-Nachricht in einen abstrakten
// Syntaxbaum.
//
// HINWEIS:
//   Der Parameter oAbstractSyntaxTree muss vor der Verwendung mithilfe der
//   Funktion "EDI_AbstractSyntaxTree_Create()" erzeugt werden.
//
// @result: null - keine Rückgabe
//******************************************************************************
function _EDI_Edifact_AST_ParseMessageString(oAbstractSyntaxTree:O, cMessageString:C, aSchemeAST:R)
   Call('EDI\Core\EdifactParser', oAbstractSyntaxTree, cMessageString, aSchemeAST, 'EDIFACT'),
end,

//******************************************************************************
// Diese Funktion verarbeitet einen EDI-Schema-String und übersetzt diesen in
// ein Codeblock-Array.
//
// @result: null - keine Rückgabe
//******************************************************************************
function _EDI_Edifact_AST_ParseSchemeString(aSchemeAST:R, cSchemeString:C)
   aSchemeAST := Call('EDI\Core\EdifactSchemeParser', cSchemeString),
end,

//##############################################################################
//##############################################################################
// Funktionen (Internal)
//##############################################################################
//##############################################################################

function _EDI_Edifact_AST_TTreeViewEx_FirstNode_Internal(oAbstractSyntaxTree:O)
   if ClassOf(oAbstractSyntaxTree, 'TTreeViewEx') then
      result := oAbstractSyntaxTree.FirstNode,
      if empty(result) then
         result       := CollAdd(oAbstractSyntaxTree.Items),
         result.Text  := 'ROOT',
         result.Value := '0',
      endif,
   else
      result := oAbstractSyntaxTree,
   endif,
end,

