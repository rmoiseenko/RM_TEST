//##############################################################################
//##############################################################################
//
// Globale Funktionen für die "Memo-Notify" Benachrichtigungs-Funktion in der
//    Groupware
//
//    Hinweise:
//    - Der Funktions-Präfix 'GMNU' steht für 'Groupware Memo Notify Utils'
//
//##############################################################################
//##############################################################################

|
   gl_GMNU_InfoTransportArray:_U,   // "Info-Transport-Array" (von "residentem" Hintergrund-Programm nach Browser-Oberfläche)
   gl_GMNU_Search_ViewId:_U,        // Ansichts-ID der Ansicht, die bei Klick auf ein Notify-Panel aktiviert werden soll

   gl_GMNU_ParamSaveId_Changed:_U,  // Speicher-Key "Änderungen anzeigen ab Zeitpunkt"
   gl_GMNU_ParamSaveId_Created:_U   // Speicher-Key "Neuanlagen anzeigen ab Zeitpunkt"
|

//##############################################################################
//##############################################################################
// Initalisierung der individuellen Variablen
//##############################################################################
//##############################################################################

gl_GMNU_InfoTransportArray  := {},
gl_GMNU_Search_ViewId       := '{9141C6E1-F4EC-4D22-A56D-3DFD3CE132EB}',
gl_GMNU_ParamSaveId_Changed := 'GMN_CT' + c_usr,
gl_GMNU_ParamSaveId_Created := 'GMN_CC' + c_usr,

//##############################################################################
//##############################################################################
// Funktionen
//##############################################################################
//##############################################################################

//******************************************************************************
// Erzeugt einen String im deutschen DatumsFormat
//    aus einer DatumsVariable, egal welches Land in Windows eingestellt ist
//
//    Hintergrund: Es konnte zu Fehlern kommen, wenn das Datums-Format sich
//                 zwischen dem Lesen und Schreiben des Werts geändert hat,
//                 da vor Nutzung dieser Funktion die Funktionen "DateTimeToStr()"
//                 und "StrToDateTime()" genutzt wurden.
//
// @Result: string
//******************************************************************************
function _GMNU_RobustDateTimeToStr(dTimeStamp)
   | nYear, nMonth, nDay, cTime |
   nYear  := year(dTimeStamp),
   nMonth := month(dTimeStamp),
   nDay   := day(dTimeStamp),
   cTime  := token(dTimestamp,' ',2),

   Result := PadL(nDay, 2, '0') + '.' + PadL(nMonth, 2, '0') + '.' + str(nYear) + ' ' + cTime,
end,

//******************************************************************************
// Erzeugt aus einem String im deutschen Datumsformat
//   ein Datum mit Time, egal welches Land in Windows eingestellt ist
// @Result: Datum
//******************************************************************************
function _GMNU_RobustStrToDateTime(cDateTime)
  | nYear, nMonth, nDay, cTime, nHour, nMinute, nSecond |
   nYear  := Val(substr(cDateTime,7,4)),
   nMonth := Val(substr(cDateTime,4,2)),
   nDay   := Val(substr(cDateTime,1,2)),
   cTime  := token(cDateTime,' ',2),
   nHour  := Val(substr(cTime,1,2)),
   nMinute:= Val(substr(cTime,4,2)),
   nSecond:= Val(substr(cTime,7,2)),

   Result := EncodeDate(nYear, nMonth , nDay) + EncodeTime(nHour, nMinute, nSecond,0),
end,

//******************************************************************************
// Stellt die aktuellen Zeitstempel "neue / geänderte Memos melden ab" in einer
// 2 globalen Variablen zur Verfügung, damit z.B. im Memo-Browser-Codeblock darauf
// zugegriffen werden kann.
// @Result: null
//******************************************************************************
function _GMNU_WriteMemoNotifyInfoToGlobalArray(dLast, nCreatedOrChanged)
  | dtimestamp |
  if ALen(gl_GMNU_InfoTransportArray) < 2 then
     ReDim(gl_GMNU_InfoTransportArray, 2),
     if empty(gl_GMNU_InfoTransportArray[2]) then
        dTimeStamp := GetAdsServerTime() - EncodeTime(0, 0, 2, 0),
        gl_GMNU_InfoTransportArray[2] := dTimestamp,
     endif,
   endif,

   if nCreatedOrChanged = 1 then
      gl_GMNU_InfoTransportArray[1] := dLast
   else
      gl_GMNU_InfoTransportArray[2] := dLast
   endif,
end,

//******************************************************************************
// Zeitstempel "neue Memos melden ab" aktualisieren
// @Result: null
//******************************************************************************
function _GMNU_SetLastMemoCreatedDateTime(dTimeStamp)
   // Kein DD vorhanden => dann können keine DB-Zugriffe gemacht werden
   // (kann passieren, wenn z.B. über die Datenbankverwaltung das DD gelöscht wird)
   if not DataDictionaryAvailable() then
      exit,
   endif,

   // Info persistent speichern, damit nach einem Neustart wieder auf dem letzten
   // Prüf-Zeitstempel aufgesetzt werden kann
   SetBeParam(gl_GMNU_ParamSaveId_Created, GMNU_RobustDateTimeToStr(dTimeStamp) ),

   GMNU_WriteMemoNotifyInfoToGlobalArray(dTimeStamp, 2),                        // Prs('_GMWU_SetLastMemoCreatedDateTime()', GMNU_RobustDateTimeToStr(dTimeStamp)),
end,

//******************************************************************************
// Zeitstempel "geänderte Memos melden ab" aktualisieren
// @Result: null
//******************************************************************************
function _GMNU_SetLastMemoChangedDateTime(dTimeStamp)
   // Kein DD vorhanden => dann können keine DB-Zugriffe gemacht werden
   // (kann passieren, wenn z.B. über die Datenbankverwaltung das DD gelöscht wird)
   if not DataDictionaryAvailable() then
      exit,
   endif,

   // Info persistent speichern, damit nach einem Neustart wieder auf dem letzten
   // Prüf-Zeitstempel aufgesetzt werden kann
   SetBeParam(gl_GMNU_ParamSaveId_Changed, GMNU_RobustDateTimeToStr(dTimeStamp) ),
   GMNU_WriteMemoNotifyInfoToGlobalArray(dTimeStamp, 1),                        // Prs('_GMWU_SetLastMemoChangedDateTime()', GMNU_RobustDateTimeToStr(dTimeStamp)),
end,

//******************************************************************************
// Zeitstempel "neue Memos melden ab" aktualisieren
// @Result: null
//******************************************************************************
function _GMNU_SetLastMemoCreatedDateTimeToNow()
| dTimeStamp |
   dTimeStamp := GetAdsServerTime() - EncodeTime(0, 0, 2, 0), // 2 Sekunden "Spiel", damit gerade eben veränderte dennoch wieder gemeldet werden
   GMNU_SetLastMemoCreatedDateTime(dTimeStamp),
end,

//******************************************************************************
// Zeitstempel "geänderte Memos melden ab" aktualisieren
// @Result: null
//******************************************************************************
function _GMNU_SetLastMemoChangedDateTimeToNow()
| dTimeStamp |
   dTimeStamp := GetAdsServerTime() - EncodeTime(0, 0, 2, 0), // 2 Sekunden "Spiel", damit gerade eben veränderte dennoch wieder gemeldet werden
   GMNU_SetLastMemoChangedDateTime(dTimeStamp),
end,

//******************************************************************************
// Zeitstempel "neue Memos melden ab" auslesen
// @Result: Timestamp
//******************************************************************************
function _GMNU_GetLastMemoCreatedDateTime()
| cDateTimeSaved |

   cDateTimeSaved := AllTrim(GetBeParam(gl_GMNU_ParamSaveId_Created)),

   // Wert noch nie gespeichert?
   if empty(cDateTimeSaved) then
      GMNU_SetLastMemoCreatedDateTimeToNow(),
      Result := GMNU_GetLastMemoCreatedDateTime()
   else
      Result := GMNU_RobustStrToDateTime(cDateTimeSaved),
   endif,

   GMNU_WriteMemoNotifyInfoToGlobalArray(Result,2),                             // Prs('GetLastMemoChangedDateTime()', GMNU_RobustDateTimeToStr(Result)),
end,

//******************************************************************************
// Zeitstempel "geänderte Memos melden ab" auslesen
// @Result: Timestamp
//******************************************************************************
function _GMNU_GetLastMemoChangedDateTime()
| cDateTimeSaved |

   cDateTimeSaved := AllTrim(GetBeParam(gl_GMNU_ParamSaveId_Changed)),
   // Wert noch nie gespeichert?
   if empty(cDateTimeSaved) then
      GMNU_SetLastMemoChangedDateTimeToNow(),
      Result  := GMNU_GetLastMemoChangedDateTime(),
   else
      Result  := GMNU_RobustStrToDateTime(cDateTimeSaved),
   endif,
   GMNU_WriteMemoNotifyInfoToGlobalArray(Result, 1),                            // Prs('GetLastMemoChangedDateTime()', GMNU_RobustDateTimeToStr(Result)),
end,

//******************************************************************************
// Hintergrund-Farbe für den Memo-Browser für die Hervorhebung von Memos, die
//   seit dem letzten Bestätigen der Änderungs-Benachrichtigung geändert oder
//   neu angelegt wurden.
// @Result: Integer, Farb-Wert
//******************************************************************************
function _GMNU_MemoBrowserBackColor(oDab065)
| oKDNGMN, dMemoNotifyLastChangedDateTime,  dMemoNotifyLastCreatedDateTime |
   Result := clNone,
   // wenn man selbst in der Liste der nächsten Aktion ist und jemand anders
   // zuletzt gespeichert hat, dann ist das interessant. Also hervorheben:
   if oDab065:MEMO_ID > 0 then
      if c_usr $ oDab065:N_AKTION then
         dMemoNotifyLastChangedDateTime := iif(ALen(gl_GMNU_InfoTransportArray) >= 1, gl_GMNU_InfoTransportArray[1], Now()),
         dMemoNotifyLastCreatedDateTime := iif(ALen(gl_GMNU_InfoTransportArray) >= 2, gl_GMNU_InfoTransportArray[2], Now()),

         // erstmal schauen, ob es überhaupt grün oder rot wird
         if    (oDab065:GEAENDERT > dMemoNotifyLastChangedDateTime or oDab065:GEAENDERT > dMemoNotifyLastCreatedDateTime)
            and oDab065:GEAEND_USR <> c_usr then

            // wenn ich einen Eintrag in der KDNMEM finde, dann neu oder geändert, sonst "nix"                                    // TODO: Performance testen!
            oKDNGMN := BeOpen(waKDNGMN, 'USER_ID_MEMO_ID'),
            startseq
               DbScope({c_usr, oDab065:MEMO_ID}, {c_usr, oDab065:MEMO_ID}, oKDNGMN),
               if not nods(oKDNGMN) then
                  if oKDNGMN:TYP == 'G' then
                     Result := Rgb(194, 214, 155), // gleicher Farb-Code wie das Memo-Notify-Panel "geänderte Memos"
                  else
                     Result := Rgb(255, 173, 130), // gleicher Farb-Code wie das Memo-Notify-Panel "neue Memos"
                  endif,
               endif,
            always
               BeClose(oKDNGMN),
            stopseq,
         endif,

      endif,
   endif,
end,

//******************************************************************************
// Funktion berechnet die Hintergrundfarbe für den Memo-Browser für die Spalte
//   "zuletzt geändert von"
// @Result: Integer, Farbe
//******************************************************************************
function _GMNU_MemoBrowser_LastChangedColor(oDab065)
   Result :=
      // wenn man selbst in der Liste der nächsten Aktion ist und jemand anders
      // zuletzt gespeichert hat, dann ist das interessant. Also hervorheben:
      iif( oDab065:MEMO_ID = 0,
           clNone,
           iif( not empty(oDab065:GEAEND_USR) and (oDab065:GEAEND_USR <> c_usr) and (c_usr $ oDab065:N_AKTION),
               Rgb(194, 214, 155), // gleicher Farb-Code wie das Memo-Notify-Panel "neue / geänderte Memos"
               clNone ) ),
end,

//******************************************************************************
// Funktion berechnet die Hintergrundfarbe für den Memo-Browser für die Spalte
//   "WV DATUM"
// @Result: Integer, Farbe
//******************************************************************************
function _GMNU_MemoBrowser_ReminderDateColor(oDab065)
   Result :=
      // Ist das Memo "heute fällig" geworden?
      // => Abbildung der gleichen Logik wie der "Memo-Notification-Watcher"
      iif(     c_usr $ oDab065:N_AKTION
           and oDab065:WVDATUM = Date()
           and oDab065:GEAENDERT < Date() + EncodeTime(0, 0, 0, 0),
           Rgb(255, 236, 186), // ähnliche Farbe wie das Memo-Notify-Info-Panel für "fällige Wiedervorlagen" (etwas mehr Kontrast)
           clnone ),
end,

//******************************************************************************
// Legt einen Notify-Datensatz an, sofern dieser noch nicht existiert
// @Result: null
//******************************************************************************
function _GMNU_WriteNotifyRecord(nMemoID, cUserID, cTyp)
   | oKDNGMN |

   oKDNGMN           := DbGetTable(gl_oDM, waKDNGMN),
   oKDNGMN.IndexName := 'USER_ID_MEMO_ID',

   if DbSeek({cUserID, nMemoID}, oKDNGMN) then
      // Wenn der Notify-Record schon vorhanden ist, dann nichts machen.
      // -> Wenn ein 'G' geschrieben werden soll und ein 'N' ist vorhanden, dann
      //    bleibt es somit beim 'N'.
   else
      MyAppend(oKDNGMN),
      oKDNGMN:MEMO_ID := nMemoID,
      oKDNGMN:USER_ID := cUserID,
      oKDNGMN:TYP     := cTyp,
      MyPost(oKDNGMN),                                                          Prs('GMNU_WriteNotifyRecord', 'Notify angelegt (+) ' + ArrToStr({nMemoID, cUserID, cTyp})),
   endif,
end,

//******************************************************************************
// Löscht einen Notify-Datensatz, sofern dieser existiert
// @Result: null
//******************************************************************************
function _GMNU_DeleteNotifyRecord(nMemoID, cUserID)
   | oKDNGMN |

   oKDNGMN           := DbGetTable(gl_oDM, waKDNGMN),
   oKDNGMN.IndexName := 'USER_ID_MEMO_ID',

   if DbSeek({cUserID, nMemoID}, oKDNGMN) then                                  Prs('GMNU_WriteNotifyRecord', 'Notify gelöscht (-) ' + ArrToStr({nMemoID, cUserID, oKDNGMN:TYP})),
      MyDelete(oKDNGMN),
   endif,
end,

//******************************************************************************
// Funktion löscht alle Notify-Einträge für einen User und einen Notify-Typ
// => wird genutzt, wenn der User das Notify-Panel mit Schließen beendet
// @Result: null
//******************************************************************************
function _GMNU_DeleteAllNotifyRecords(cUserID, cTyp)
   | oKDNGMN |

   cTyp := Upper(AllTrim(cTyp)),
   SetErrorIf(cTyp <> 'N' and cTyp <> 'G', 'cType must be "N" oder "G"'),

   oKDNGMN           := DbGetTable(gl_oDM, waKDNGMN),
   oKDNGMN.IndexName := 'USER_ID_MEMO_ID',

   DbFilter('USER_ID = "' + cUserID + '" AND TYP = "' + cTyp + '"', oKDNGMN),
   startseq
     while not EoF(oKDNGMN) do
        DbGoTop(oKDNGMN),
        MyDelete(oKDNGMN),
     end,
   always
     DbFilter('', oKDNGMN),
   stopseq,
end,

//******************************************************************************
// Erzeugt eine MemTable für den Abgleich der Userlisten der "nächsten Aktion"
//    "alt" und "neu" (vor und nach dem Speichern eines Memos)
// @Result: MemTable
//******************************************************************************
function _GMNU_UserCompareMemTable_CreateMemTable()
   Result  := CreateObject('TBeMemTable'),
   startseq
      Result.CbAddField('USER',               ftString,   3),
      Result.CbAddField('OLD',                ftBoolean,  0),
      Result.CbAddField('NEW',                ftBoolean,  0),

      Result.Active := True,

      Result.CbAddIndex('USER', 'USER', ixPrimary),
   onerror
       Result := nil,
       DestroyObject(Result),
   stopseq,
end,

//******************************************************************************
// Fügt den User "cUser" der MemTable hinzu als "in alter Userliste"
//******************************************************************************
function _GMNU_UserCompareMemTable_AppendOld(oUserMem, cUser)
   oUserMem.CbAppend(),
   oUserMem:USER := cUser,
   oUserMem:OLD  := true,
   oUserMem:NEW  := false,
   oUserMem.CbPost(),
end,

//******************************************************************************
// Fügt den User "cUser" der MemTable hinzu als "in neuer Userliste"
//******************************************************************************
function _GMNU_UserCompareMemTable_AppendOrMarkNew(oUserMem, cUser)
   if oUserMem.CbFindKey({cUser}) then
      oUserMem.CbEdit(),
      oUserMem:NEW  := true,
      oUserMem.CbPost(),
   else
      oUserMem.CbAppend(),
      oUserMem:USER := cUser,
      oUserMem:OLD  := false,
      oUserMem:NEW  := true,
      oUserMem.CbPost(),
   endif,
end,

//******************************************************************************
// Funktion vergleicht zwei Userlisten ("Nächste Aktion" DAB065:NAKTION)
//   beim Speichern eines Memo.
//   Auf Basis der erkannten Änderungen werden Notify-Datensätze erzeugt,
//   geändert oder gelöscht
// @Result: null
//******************************************************************************
function _GMNU_UpdateNotifyTable(nMemoID, cCurrentUser, cUserlistOld, cUserlistNew)
| oUserCompareMem, i, cCurUserToken |

   oUserCompareMem := GMNU_UserCompareMemTable_CreateMemTable(),
   startseq

      // 1. "alte Userliste" in Memtable eintragen
      if not empty(cUserlistOld) then
         for i := 1 to TokenCount(cUserlistOld, '/') do
            cCurUserToken := Token(cUserlistOld, '/', i),
            if not empty(cCurUserToken) then
               GMNU_UserCompareMemTable_AppendOld(oUserCompareMem, cCurUserToken),
            endif,
         next,
      endif,

      // 2. "neue Userliste" in Memtable ergänzen
      if not empty(cUserlistNew) then
         for i := 1 to TokenCount(cUserlistNew, '/') do
            cCurUserToken := Token(cUserlistNew, '/', i),
            if not empty(cCurUserToken) then
               GMNU_UserCompareMemTable_AppendOrMarkNew(oUserCompareMem, cCurUserToken),
            endif,
         next,
      endif,

      // 3. Änderungen in Notify-Tabelle eintragen
      //    -> Die MemTable enthält jetzt einen Datensatz für jeden User, der
      //       vorher und / oder nachher in der "nächsten Aktion" stand.
      oUserCompareMem.CbFirst(),
      while not oUserCompareMem.CbEof do
         // Sonderbehandlung für den speichernden User
         if oUserCompareMem:USER == cCurrentUser then
            GMNU_DeleteNotifyRecord(nMemoID, oUserCompareMem:USER),
         else
            // User ist neu hinzugekommen?
            if not oUserCompareMem:OLD and oUserCompareMem:NEW then
               GMNU_WriteNotifyRecord(nMemoID, oUserCompareMem:USER, 'N'),
            else
               // User rausgefallen ?
               if oUserCompareMem:OLD and not oUserCompareMem:NEW then
                  GMNU_DeleteNotifyRecord(nMemoID, oUserCompareMem:USER),
               else // User weiterhin in "Nächste Aktion"
                  GMNU_WriteNotifyRecord(nMemoID, oUserCompareMem:USER, 'G'),
               endif,
            endif,
         endif,

         oUserCompareMem.CbNext(),
      end,

   always
      DestroyObject(oUserCompareMem),
   stopseq,
end,

//******************************************************************************
// Funktion ist gedacht für die Nutzung im Kopf-Update-Trigger Recht der Dab065
// -> ermittelt den alten Wert von "nächste Aktion" vor dem Speichern
//
//    Die Funktion wird im Update-Trigger ausgelöst und nicht im
//    Event "Memo\vor dem Speichern", da im Event die
//    (Feld-)Validierungen noch nicht ausgeführt wurden und somit ein ggf.
//    überhaupt nicht relevanter Zwischenstand des Memo-Datensatzes für das Schreiben
//    der Notify-Infos genutzt würde.
//
//    Da beim Speichern eines Memo über die GUI keine Transaktion aktiv ist
//    (Stand 2015-06), würden fehlerhafte Datensätze entstehen, wenn mit dem
//    Event "Memo\vor dem Speichern" gearbeitet würde.
//
// @Result: null
//******************************************************************************
function _GMNU_HandleDab065UpdateTrigger(oDab065)
   | cOldNAktion, cNewNAktion |

   if DbState(oDab065) = dsInsert then
      cOldNAktion := '',
   else
      // Der "vorherige Zustsand" muss per LookUp() ermittelt werden, da für
      // MEMO/BLOB-Felder defaultmäßig keine DbOldVal()-Werte verfügbar sind.
      cOldNAktion := LookUp(waDab065, 'DAB06B', {{oDab065:MEMO_ID}}, 'AllTrim(N_AKTION)', ''),
   endif,

   cNewNAktion := AllTrim(oDab065:N_AKTION),

   GMNU_UpdateNotifyTable(oDab065:MEMO_ID, c_usr, cOldNAktion, cNewNAktion),
end,
