//##############################################################################
//##############################################################################
// Beschreibung: Dokumenten-Docking für die Verwaltung von Dokumenten, die dem
//               entsprechenden Master-Datensatz zugeordnet sind.
//
// Aufruf: Siehe Demo-Individual-Menü-Datei "Dokumente (1234).BIM"
//##############################################################################
//##############################################################################

|
   m_oOwnerForm:P1, m_cFormRefKey:P2, m_oMasterTable:P3,  // Übergabe-Parameter für GFU-Funktionen

   m_cFormClassID, m_cBrowserID, m_nMasterWorkarea, m_nMasterIdOrArtNr,
   m_cPositionSaveId, m_oIndiMenu,

   m_oDM_Gui, m_oDmsVer_Mask, m_oTree,
   m_nKategorienFilter, m_cContainsFilter,
   m_cParamLastFolder,
   m_bMasterTableIsInEditMode, m_bExplicitPost, m_bExplicitInsert,
   m_oDmsVerVersions,
   m_oDmsVer_MemGrid,
   m_oDabMdtKategorieMem, m_nTotalSichtbar,

   oSelectBox,
   // @VDB@ der nachfolgende Teil wird automatisch gepflegt
   oForm, A_AktiveAnzeigen, A_Cancel, a_DatumUser, A_Delete, A_DeleteEndgueltig,
   A_KuenftigeAnzeigen, A_LoadFileOrDefineLink, A_NewDocument, A_NewFilelink,
   A_NewFileScan, A_NewHyperlink, A_NewVersion, A_OpenFileDocument,
   A_OpenFileOrHyperlink, a_reactivate, A_Refresh, A_Save, A_SaveFile,
   a_showDeleted, A_StatusAktuelleVersion, A_StatusInBearbeitung,
   A_StatusVeraltet, A_StatusZurUeberpruefung, A_VeralteteAnzeigen,
   A_Zugriffsberechtigung, Actions, BeBarButton1, BeBarDockControl1,
   BeBarDockControl2, BeBarDockControlDeleteButton, BeBarManager,
   BeBarManagerBar1, BeBarManagerBar2, BeBarManagerBar4, BeBarManagerStatusBar1,
   BeBarSeparator1, BeBarSubItem1, Bevel1, Bevel2, bipnl_DevInfos,
   bipnl_NoActionForSemaphorInsert, bipnl_TableNotSynchronized, btn_datumUser,
   btn_delete, btn_LoadFileOrDefineLink_File, btn_LoadFileOrDefineLink_Link,
   btn_loeschen, btn_OpenFileDocument, btn_OpenFileOrHyperlink, btn_reactivate,
   btn_refresh, btn_SaveDocumentFile, btn_SaveLinkFile, btn_ShowDeleted,
   btn_StatusAktuelleVersion, btn_StatusInBearbeitung, btn_StatusVeraltet,
   btn_StatusZurUeberpruefung, cmb_DocumentAccessCategory,
   cmb_DocumentApprovalState, cmb_DocumentCategory, cmb_DocumentConfidentiality,
   cmb_DocumentResposibility, cmb_DocumentState, cmb_DocumentType,
   cmb_DocumentUsage, ds_Documents_Grid, ds_Documents_Mask, ds_MainTable,
   edt_DocumentName, edt_DocumentNo, edt_DocumentVersDesc, edt_DocumentVersNo,
   edt_FileChangeDate, edt_FileOrHyperLink, edt_FileSize, edt_FileType,
   edt_searchText, grd_main, lbl_DocumentAccessCategory,
   lbl_DocumentApprovalState, lbl_DocumentCategory, lbl_DocumentConfidentiality,
   lbl_DocumentLinkData, lbl_DocumentLinkDataInfo, lbl_DocumentName,
   lbl_DocumentNo, lbl_DocumentResponsibility, lbl_DocumentState,
   lbl_DocumentType, lbl_DocumentUsage, lbl_DocumentVersDesc,
   lbl_DocumentVersNo, lbl_File, lbl_FileChangeDate, lbl_FileSize, lbl_FileType,
   lbl_geloescht, lbl_Memo, MainMenu1, pnl_DatumUser, pnl_File, pnl_FileButtons,
   pnl_FileCaption, pnl_FileLinkOrHyperLink, pnl_FileLinkOrHyperLinkCaption,
   pnl_Filter, pnl_geloeschteanzeigen, pnl_Grid, pnl_leftTree, pnl_LinkButtons,
   pnl_Main, pnl_Mask, pnl_MaskBottomArea, pnl_MaskTopArea, pnl_MemoArea,
   pnl_MiddleGrid, pnl_StatusFilter, pnl_StatusToolBarParent, pnl_Top,
   richedit_DocumentMemo, splitter_Mask, sub_StatusAendern, SubLoeschen,
   tb_Cancel, tb_NewDocument, tb_NewFileLink, tb_NewFileScan, tb_NewHyperlink,
   tb_NewVersion, tb_save, tb_Zugriffsberechtigung
   // @VDE@ der vorangehende Teil wird automatisch gepflegt
|

//##############################################################################
//##############################################################################
// Konstanten
//##############################################################################
//##############################################################################

m_cFormClassID     := '@DMS_GUI',
m_cPositionSaveId  := '@DMS_GUI',
m_cBrowserID       := '@DMS_GUI',
m_cParamLastFolder := '@BE_DMS', // Parameter-Key für letztes genutztes Windows-Verzeichnis

//##############################################################################
//##############################################################################
// Funktionen
//##############################################################################
//##############################################################################

//******************************************************************************
// Datenmodul und Tabellen für das Form öffnen
// @Result: null
//******************************************************************************
function OpenDataBaseAndLinkToGUI()
   | oDabMdt, oRec |
   startseq,
      iif(empty(m_oMasterTable), SetError('This docking cannot be used without mastertable.'), ),
      m_nMasterWorkarea := m_oMasterTable.Workarea,
      // Lokales DataSource mit der übergebenen Master-Tabelle verbinden,
      // damit eine (eigene, lokale) Komponente mit den notwendigen Events zur
      // Reaktion auf Master-Table-Aktionen bereit steht

      GFU_Docking_LinkMasterTableToLocalDataSource(m_oMasterTable, ds_MainTable, -1, ''),

      m_oDM_Gui := CreateObject( 'TBeDbGet', , oForm ),

      DMSU_CreateF12ContainerForAccessRights(m_oDM_Gui, oForm),
      m_oDmsVer_Mask                  := DbGetTable(m_oDM_Gui, waDmsVer,),
      m_oDmsVer_Mask.CheckReadAccess  := raFilter,  // Leserechte berücksichtigen
      m_oDmsVer_Mask.CheckUserRights  := True,      // Berechtigungen prüfen
      m_oDmsVer_Mask.IndexName        := 'ID',

      m_oDmsVer_MemGrid                   := CreateObject('TBeMemTable'),
      m_oDmsVer_MemGrid.CbLoadFields(waDMSVER, 'DMSVER_MEM', '', 'MEMO,SUCHE'), // Diese Felder werden nicht übernommen, um beim Kopieren Performance zu sparen
      m_oDmsVer_MemGrid.CbAddField('CALC_COMBINED_DOC_NR_VERS_NR', ftString, 25),
      m_oDmsVer_MemGrid.CbAddField('CALC_DOC_NR_ALTERNATE',        ftInteger, 0),
      m_oDmsVer_MemGrid.CbAddIndex('WORKAREA', 'WORKAREA;DS_ID;DOC_NR;VERS_NR', ixPrimary),
      m_oDmsVer_MemGrid.Active             := true,

      // Memtable der Kategorien zur Füllung des Tree
      m_oDabMdtKategorieMem :=   CreateObject('TBeMemTable'),
      startseq
         oDabMdt := beopen(waDabMdt),
         dbscope({gl_DMSU_MMTabellenID_Kategorie},{gl_DMSU_MMTabellenID_Kategorie}, oDabMdt),
         m_oDabMdtKategorieMem.CbBorrowFromDataset(oDabMdt),
         m_oDabMdtKategorieMem.Active             := false,
         m_oDabMdtKategorieMem.CbAddField('ANZAHL', ftInteger, 0),
         m_oDabMdtKategorieMem.CbAddIndex('WERT', 'WERT', ixPrimary),
         m_oDabMdtKategorieMem.Active             := true,
         m_oDabMdtKategorieMem.CbLoadFromDataSet(oDabMdt, True),
      always
         beclose(oDabMdt),
      stopseq,
      foreach oRec in m_oDabMdtKategorieMem do
         MyEdit(m_oDabMdtKategorieMem),
         m_oDabMdtKategorieMem:BEZ1 := AttribDispVal(gl_DMSU_MMTabellenID_Kategorie, alltrim(m_oDabMdtKategorieMem:WERT)),
         MyPost(m_oDabMdtKategorieMem),
      next,
      // Browser mit MemTable verbinden
      grd_Main.UseOnlyRegisteredDataSets := true,
      GU_LinkTableToGUI(m_oDmsVer_MemGrid, ds_Documents_Grid, grd_Main, m_cBrowserID, false),
      grd_Main.CbChangeOrder := true, // Sortierung über die Spaltenköpfe zulassen
      grd_Main.GridOrder     := 'CALC_COMBINED_DOC_NR_VERS_NR',

      // Maske mit RightsTable verbinden
      ds_Documents_Mask.DataSet     := m_oDmsVer_Mask,

      AssignEvent(m_oDmsVer_Mask,    'BeforeEdit',      'DMSVER_Mask_BeforeEdit'),
      AssignEvent(m_oDmsVer_Mask,    'BeforeInsert',    'DMSVER_Mask_BeforeInsert'),
      AssignEvent(m_oDmsVer_Mask,    'AfterCancel',     'DMSVER_Mask_AfterCancel'),
      AssignEvent(m_oDmsVer_Mask,    'BeforePost',      'DMSVER_Mask_BeforePost'),
      AssignEvent(m_oDmsVer_MemGrid, 'BeforeScroll',    'DMSVER_MemGrid_BeforeScroll'),

   onerror,
      SetError('Fehler in OpenTables(): ' + GetErrorText()),
   stopseq,
end,

//******************************************************************************
// Funktion zum ermitteln der MatserTable-ID
//    Funktion kann beliebig erweitert werden für Fälle in der sich DMS auf kein
//    "ID"-Feld bezieht
//
// @Result: numeric
//******************************************************************************
function DMSU_GetMasterIdOrArtNr()
   Result := m_oMasterTable:ID,
   case m_nMasterWorkarea
      of waDab065 :: Result := m_oMasterTable:MEMO_ID,
      of waDab010 :: Result := iif(gl_DMSU_ShowAllDocsForArtNr, m_oMasterTable:ARTNR, m_oMasterTable:ID),
      otherwise      Result := m_oMasterTable:ID
   endcase,
end,

//******************************************************************************
// Fügt einen neuen Knoten für eine Kategorie auf Basis der MM-Tabelle Kategorie
// hinzu.
// @Result: null
//******************************************************************************
function AddElementKategorie(oDabMdtKategorieMem)
| oLastNode, cBez, aImageIndex, nImageIndex, oMasterNode |
   cBez        := oDabMdtKategorieMem:BEZ1,
   oMasterNode := m_oTree.FirstNode,
   oLastNode   := oMasterNode.AddChild,
   //aImageIndex := oDabMdtKategorieMem:IMG_INDEX,
   //nImageIndex := iif(empty(oDabMdtKategorieMem:IMG_LISTE), -1, aImageIndex[2]),

   oLastNode.ImageIndex    := oDabMdtKategorieMem:IMG_INDEX,
   oLastNode.SelectedIndex := oDabMdtKategorieMem:IMG_LISTE,
   oLastNode.Text          := alltrim(cBez) + ' (' + str(oDabMdtKategorieMem:ANZAHL) + ')',
   oLastNode.Value         := oDabMdtKategorieMem:WERT,
   if oLastNode.Value = m_nKategorienFilter then
      oLastNode.Text       := '--> ' + oLastNode.Text,
   endif,
end,

//******************************************************************************
// Die Funktion befüllt die Memtable das Tree.
// Die Funktion hat keine Rückabe.
//******************************************************************************
function DMSU_FillDocumentTree()
|  i, aKategorie, cKategorie, oMasterNode, oDabMdt |
   // Hauptknoten erzeugen
   oMasterNode := CollAdd(m_oTree.Items),
   oMasterNode.Text          := 'Alle Dokumente ' + ' (' + Str(m_nTotalSichtbar) + ')',
   oMasterNode.ImageIndex    := 350,
   oMasterNode.SelectedIndex := 350,

   // MM-Tabelle durchgehen und als Kategorie hinzufügen
   DbGoTop(m_oDabMdtKategorieMem),
   while not eof(m_oDabMdtKategorieMem) do
      if m_oDabMdtKategorieMem:ANZAHL > 0 then
         AddElementKategorie(m_oDabMdtKategorieMem),
      endif,
      DbSkip(m_oDabMdtKategorieMem),
   end,
end,

//******************************************************************************
// Die Funktion initialisiert einen Treeview.
// Rückgabe ist das TreeView
//******************************************************************************
function DMSU_CreateDocumentTree(oParent)
   m_oTree        := CreateObject('TTreeViewEx','Tree', oForm, oForm),
   m_oTree.Images := FindObject(FindObject(Application, 'DM_ImageList'), 'ImageListMain'),

   m_oTree.ShowLines   := false,
   m_oTree.ShowButtons := false,
   m_oTree.RowSelect   := false,
   m_oTree.HotTrack    := false,
   m_oTree.HideSelection := false,


   SetParent(m_oTree, oParent),
   m_oTree.align  := alClient,

   AssignEvent(m_oTree, 'OnClick', 'OnTreeViewClick'),
end,

//******************************************************************************
// Die Funktion Löscht und erzeugt das Baum-Objekt neu
// Sie ruft die Funktion zur Füllung des Baumes auf.
// Die Funktion hat keine Rückabe.
//******************************************************************************
function DMSU_CreateAndFillDokumentTree()
| oFirstNode |
   if Empty(m_oTree) then
      DMSU_CreateDocumentTree(pnl_LeftTree),
   else
      // Alle existierenden Knoten aus dem Baum entfernen
      m_oTree.BeginUpdate,
      startseq
         oFirstNode := m_oTree.FirstNode,
         if not empty(oFirstNode) then
            oFirstNode.FreeTree,
         endif,
      always
         m_oTree.EndUpdate,
      stopseq,
   endif,

   m_oTree.BeginUpdate,
   startseq
      DMSU_FillDocumentTree(),
      m_oTree.FullExpandTree,
   always
      m_oTree.EndUpdate,
   stopseq,
end,

//******************************************************************************
// Aktualisiert die Entwickler-Informationen
//******************************************************************************
function RefreshDevInfo()
   bipnl_DevInfos.Caption :=
      'DevInfos: ' + crlf +
      'Master-Workarea = ' + Str(m_nMasterWorkarea) + ' / Master-ID = ' + crlf + iif(m_nMasterWorkarea = waDab010 and gl_DMSU_ShowAllDocsForArtNr, m_nMasterIdOrArtNr, Str(m_nMasterIdOrArtNr)) +
      'Temp-Path = ' + DMSU_CalcUserTempPath(c_usr),
end,

//******************************************************************************
// Das Panel mit den Infos zur Datei / dem Link aktualisieren
// => unterschiedliche Panels für Datei / Link sind vorhanden
// @Result: null
//******************************************************************************
function RefreshFileOrLinkPanel()                                               // TODO integrieren in ActionsEnabled
| bIsFile |                                                                     Prs(ProgName(), 'RefreshFileOrLinkPanel() - START'),
   if not empty(m_oDmsVer_Mask) then
      bIsFile                         := m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_File,
      pnl_File.Visible                := bIsFile,
      pnl_FileLinkOrHyperLink.Visible := not bIsFile,
      edt_FileOrHyperLink.Text        := iif(bIsFile, '', m_oDmsVer_Mask:LINKS),
      edt_FileSize.Text               := iif(bIsFile, DMSU_FileBytesToString(m_oDmsVer_Mask:FILE_SIZE), ''),

      case m_oDmsVer_Mask:ART
         of gl_DMSU_DokumentenArt_Filelink  :: lbl_DocumentLinkData.Caption := 'Datei-Link',
         of gl_DMSU_DokumentenArt_Hyperlink :: lbl_DocumentLinkData.Caption := 'Hyperlink',
         otherwise lbl_DocumentLinkData.Caption := '',
      endcase,
   endif,
end,

//******************************************************************************
// ActionsEnabled
// @Result: null
//******************************************************************************
function ActionsEnabled()
| bMasterRecordAvail, bDocumentAvail |                                          Prs(ProgName(), 'ActionsEnabled() - START'),
   if empty(m_oDmsVer_Mask) then
      exit,
   endif,

   bMasterRecordAvail     := not empty(m_nMasterIdOrArtNr),
   bDocumentAvail         := m_oDmsVer_Mask:ID > 0,

   // Neues Dokument
   A_NewDocument.Enabled          := not EditModes(m_oDmsVer_Mask) and bMasterRecordAvail and not m_bMasterTableIsInEditMode,
   A_NewFileScan.Enabled          := not EditModes(m_oDmsVer_Mask) and bMasterRecordAvail and not m_bMasterTableIsInEditMode,
   A_NewFilelink.Enabled          := not EditModes(m_oDmsVer_Mask) and bMasterRecordAvail and not m_bMasterTableIsInEditMode,
   A_NewHyperlink.Enabled         := not EditModes(m_oDmsVer_Mask) and bMasterRecordAvail and not m_bMasterTableIsInEditMode,
   A_Zugriffsberechtigung.Enabled := mBeSuperVisor,
   A_Zugriffsberechtigung.Visible := mBeSuperVisor,
   // Neue Version
   A_NewVersion.Enabled   := not EditModes(m_oDmsVer_Mask) and
                             bMasterRecordAvail and bDocumentAvail and
                             not m_bMasterTableIsInEditMode
                             and empty(m_oDmsVer_Mask:LOESCH_USR)
                             and DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR),

   // Datei laden
   A_LoadFileOrDefineLink.Enabled := bDocumentAvail and empty(m_oDmsVer_Mask:LOESCH_USR) and DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR),
   case m_oDmsVer_Mask:ART
      of gl_DMSU_DokumentenArt_File ::
                if empty(m_oDmsVer_Mask:D_GUID_STR) then
                   A_LoadFileOrDefineLink.Caption       := 'Datei laden',
                else
                   A_LoadFileOrDefineLink.Caption       := 'Datei ersetzen',
                endif,
                A_LoadFileOrDefineLink.ImageIndex    := 426,

      of gl_DMSU_DokumentenArt_Filelink ::
                A_LoadFileOrDefineLink.Caption       := 'Datei-Link ändern',
                A_LoadFileOrDefineLink.ImageIndex    := 62,

      of gl_DMSU_DokumentenArt_Hyperlink ::
                A_LoadFileOrDefineLink.Caption       := 'Hyperlink ändern',
                A_LoadFileOrDefineLink.ImageIndex    := 74,
   endcase,

   // Actions neu zuweisen, sonst werden Symbole nicht aktualisiert
   btn_LoadFileOrDefineLink_File.Action := A_LoadFileOrDefineLink,
   btn_LoadFileOrDefineLink_Link.Action := A_LoadFileOrDefineLink,

   // Bearbeitung
   A_Save.Enabled             := EditModes(m_oDmsVer_Mask) and not m_bMasterTableIsInEditMode,
   A_Cancel.Enabled           := EditModes(m_oDmsVer_Mask) and not m_bMasterTableIsInEditMode,

   // Löschen und Reaktivieren
   A_DeleteEndgueltig.Visible := gl_DMSU_bCanDeletePermanently,
   A_DeleteEndgueltig.Enabled := gl_DMSU_bCanDeletePermanently and not EditModes(m_oDmsVer_Mask) and
                                 bMasterRecordAvail and bDocumentAvail and not m_bMasterTableIsInEditMode
                                 and DMSU_CheckPermission_DELETE_ENDGUELTIG(m_oDmsVer_Mask:KATEG_ZUGR),
   A_Delete.Enabled           := not EditModes(m_oDmsVer_Mask) and
                                 bMasterRecordAvail and bDocumentAvail and not m_bMasterTableIsInEditMode
                                 and empty(m_oDmsVer_Mask:LOESCH_USR)
                                 and DMSU_CheckPermission_DELETE(m_oDmsVer_Mask:KATEG_ZUGR),
   A_Reactivate.Enabled       := not EditModes(m_oDmsVer_Mask) and
                                 bMasterRecordAvail and bDocumentAvail and not m_bMasterTableIsInEditMode
                                 and not empty(m_oDmsVer_Mask:LOESCH_USR)
                                 and DMSU_CheckPermission_DELETE(m_oDmsVer_Mask:KATEG_ZUGR),
   A_ShowDeleted.Enabled      := not EditModes(m_oDmsVer_Mask) and
                                 bMasterRecordAvail and not m_bMasterTableIsInEditMode,

   A_Refresh.Enabled          := not EditModes(m_oDmsVer_Mask) and
                                 bMasterRecordAvail and bDocumentAvail and not m_bMasterTableIsInEditMode,
   if empty(m_oDmsVer_Mask:LOESCH_USR) then
       lbl_geloescht.Caption := '',
   else
       lbl_geloescht.Caption := 'gelöscht am: ' + FormatDateTime('DD.MM.YYYY hh:nn', m_oDmsVer_Mask:GELOESCHT) + ' von ' + BeUserName(m_oDmsVer_Mask:LOESCH_USR),
   endif,

   // Datei / Link öffnen
   A_OpenFileDocument.Enabled    := m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_File and
                                    m_oDmsVer_Mask:FILE_SIZE > 0 and
                                    not m_bMasterTableIsInEditMode
                                    and DMSU_CheckPermission_OPEN(m_oDmsVer_Mask:KATEG_ZUGR),
   A_OpenFileOrHyperlink.Enabled := m_oDmsVer_Mask:ART <> gl_DMSU_DokumentenArt_File
                                    and not empty(m_oDmsVer_Mask:LINKS)
                                    and not m_bMasterTableIsInEditMode
                                    and m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_Hyperlink or
                                    (m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_Filelink and DMSU_CheckPermission_OPEN(m_oDmsVer_Mask:KATEG_ZUGR)),
   // Speichern unter
   A_SaveFile.Enabled := not m_bMasterTableIsInEditMode and
                         DMSU_CheckPermission_OPEN(m_oDmsVer_Mask:KATEG_ZUGR) and
                         ( (m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_File and m_oDmsVer_Mask:FILE_SIZE > 0) or
                          (m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_Filelink and not empty(m_oDmsVer_Mask:LINKS)) ),

   A_SaveFile.Visible := m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_File or m_oDmsVer_Mask:ART = gl_DMSU_DokumentenArt_Filelink,

   a_DatumUser.Enabled := not m_bMasterTableIsInEditMode and  DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR) and not noDS(m_oDmsVer_Mask), ,

   btn_StatusVeraltet.Enabled         := not noDS(m_oDmsVer_Mask) and DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR) and not m_bMasterTableIsInEditMode and m_oDmsVer_Mask:STATUS <> gl_DMSU_DokumentenStatus_Veraltet,
   btn_StatusAktuelleVersion.Enabled  := not noDS(m_oDmsVer_Mask) and DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR) and not m_bMasterTableIsInEditMode and m_oDmsVer_Mask:STATUS <> gl_DMSU_DokumentenStatus_aktuelleVersion,
   btn_StatusInBearbeitung.Enabled    := not noDS(m_oDmsVer_Mask) and DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR) and not m_bMasterTableIsInEditMode and m_oDmsVer_Mask:STATUS <> gl_DMSU_DokumentenStatus_inBearbeitung,
   btn_StatusZurUeberpruefung.Enabled := not noDS(m_oDmsVer_Mask) and DMSU_CheckPermission_WRITE(m_oDmsVer_Mask:KATEG_ZUGR) and not m_bMasterTableIsInEditMode and m_oDmsVer_Mask:STATUS <> gl_DMSU_DokumentenStatus_zurUeberpruefung,

   bipnl_NoActionForSemaphorInsert.Visible := m_bMasterTableIsInEditMode,

   grd_main.CbRefreshShowOnlyWhen(),
   grd_main.CbRefreshDynamicCaption(),

   RefreshFileOrLinkPanel(),
end,
//******************************************************************************
// Das im Grid positionierte Dokument in der Masken-Tabelle anzeigen
// @Result: null
//******************************************************************************
function SyncMaskTableToGridTable()
   startseq
      if not Empty(m_oDmsVer_Mask) and m_oDmsVer_Mask.Active and not EditModes(m_oDmsVer_Mask) then
         // Synchronisierung ergibt keinen Sinn, wenn der Datensatz gerade editiert wird.
         if m_oDmsVer_MemGrid:ID > 0 then
            DbScope(, m_oDmsVer_Mask),
            // Eigentlich muss es das Dokument in der DMSVER immer geben, schließlich ist es ja in die MemTable kopiert worden
            // Aber: -       Es könnte inzwischen gelöscht worden sein
            //       - oder: Jemand anders hat das Dokument zwischenzeitlich bearbeitet und jetzt darf der User es nicht mehr sehen
            if DbSeek({m_oDmsVer_MemGrid:ID}, m_oDmsVer_Mask) then
               // => gefunden, dennoch prüfen, ob (immernoch) Leserechte vorhanden
               if not DMSU_CheckPermission_READ(m_oDmsVer_Mask:KATEG_ZUGR) or (not empty(m_oDmsVer_MemGrid:LOESCH_USR) and not a_showDeleted.Checked) then
                  MyDelete(m_oDmsVer_MemGrid), // Datensatz aus der MemTable (Grid) löschen! => löst wieder die Scroll_Update-Events aus und hüpft auf den nächsten Satz
               endif,
            else
               // => Dokument wurde gelöscht
               MyDelete(m_oDmsVer_MemGrid), // Datensatz aus der MemTable (Grid) löschen! => löst wieder die Scroll_Update-Events aus und hüpft auf den nächsten Satz
            endif,
         else
            DbScope({-1}, {-1}, m_oDmsVer_Mask),
         endif,
         ActionsEnabled(),
      endif,
   onerror
      GU_ShowStdErrorMessage('Fehler beim Sychronisieren des Maskendatensatzes', GetErrorObj()),
   stopseq,

end,

//******************************************************************************
// Lädt die Daten in die Memtable (löscht zuvor alle bestehenden Daten)
// @Result: null
//******************************************************************************
function FillMemTable(oDmsVer, nNewDocID)
| oRec, i, oField, nDocNrAlternate, nLastDocNr,
  nCurrentRecordID, nPreviousRecordID, nNextRecordID, bRecordFound
|
   DbDisableControls(m_oDmsVer_MemGrid),
   startseq
      // Nach Neuanlage darf man nicht versuchen, auf den letzten Datensatz zu
      // positionieren, sondern muß auf den neuen Datensatz positionieren!
      if nNewDocID = 0 then
         nPreviousRecordID := -1,
         nNextRecordID     := -1,
         nCurrentRecordID  := -1,
         if not m_oDmsVer_MemGrid.CbNoDataAvailable then
            nCurrentRecordID      := m_oDmsVer_MemGrid:ID,
            if DbSkip(-1, m_oDmsVer_MemGrid) then
               nPreviousRecordID  := m_oDmsVer_MemGrid:ID,
               DbSkip(1, m_oDmsVer_MemGrid),
            endif,
            if DbSkip(1, m_oDmsVer_MemGrid) then
               nNextRecordID   := m_oDmsVer_MemGrid:ID,
            endif,
         endif,
      endif,
      m_oDmsVer_MemGrid.CbEmptyTable(),
      nDocNrAlternate := 0,
      nLastDocNr      := -1,

      foreach oRec in m_oDabMdtKategorieMem do
         m_oDabMdtKategorieMem.CbEdit(),
         oRec:ANZAHL := 0,
         m_oDabMdtKategorieMem.CbPost(),
      next,
      m_nTotalSichtbar := 0,

      foreach oRec in oDmsVer do
         // Hier werden jetzt die Lese - und Löschrechte betrachtet.
         // Das Dokument gehört in die Memtable, wenn
         //    - Der User das Leserecht für die Kategorie hat
         //    - und (das Dokument nicht gelöscht ist
         //           oder das Dokument gelöscht ist aber 'gelöschte anzeigen' ist aktiv)'
         //    - und
         //      (künftige anzeigen ist gecheckt und (STATUS = 'in Bearbeitung' oder STATUS 'zur Überprüfung')
         //      oder aktive anzeigen ist gecheckt und STATUS = 'aktiv'
         //      oder veraltete anzeigen ist gecheckt und STATUS = 'veraltet')

         if DMSU_CheckPermission_READ(oDmsVer:KATEG_ZUGR)
            and (empty(oDmsVer:LOESCH_USR) or a_showDeleted.Checked)
            and oDmsVer.CbCheckRight_Read()
            and ((at('2',oSelectBox.SelectedAsIDString) > 0 and (oDmsVer:STATUS = gl_DMSU_DokumentenStatus_zurUeberpruefung or oDmsVer:STATUS = gl_DMSU_DokumentenStatus_inBearbeitung))
                or (at('1',oSelectBox.SelectedAsIDString) > 0 and oDmsVer:STATUS = gl_DMSU_DokumentenStatus_aktuelleVersion)
                or (at('0',oSelectBox.SelectedAsIDString) > 0 and oDmsVer:STATUS = gl_DMSU_DokumentenStatus_Veraltet)
                )
            then
            if m_oDabMdtKategorieMem.CbFindKey({str(oDMSVER:KATEGORIE)}) then
               writeln(oDMSVER:ID, oDMSVER:KATEGORIE, m_oDabMdtKategorieMem:BEZ1),
               m_oDabMdtKategorieMem.CbEdit(),
               m_oDabMdtKategorieMem:ANZAHL += 1,
               m_oDabMdtKategorieMem.CbPost(),
            endif,
            m_nTotalSichtbar += 1,

            if oDMSVER:KATEGORIE = m_nKategorienFilter or m_nKategorienFilter = 0 then
               m_oDmsVer_MemGrid.CbAppend(),
               for i := 1 to m_oDmsVer_MemGrid.CbFieldCount do
                  oField := DbField(i, m_oDmsVer_MemGrid),
                  if oField.FieldName <> 'MEMO' and oField.FieldName <> 'SUCHE' then
                     DbReplace(DbField(oField.FieldName, m_oDmsVer_MemGrid), AsVariant(oField.FieldName, oDmsVer)),
                  endif,
               end,
               m_oDmsVer_MemGrid:CALC_COMBINED_DOC_NR_VERS_NR := StrZero(m_oDmsVer_MemGrid:DOC_NR, 20)  + StrZero(m_oDmsVer_MemGrid:VERS_NR,5),
               if m_oDmsVer_MemGrid:DOC_NR <> nLastDocNr then
                  nDocNrAlternate := iif(nDocNrAlternate = 0, 1, 0), // hin und herschalten zwischen 0 und 1
                  nLastDocNr      := m_oDmsVer_MemGrid:DOC_NR,
               endif,
               m_oDmsVer_MemGrid:CALC_DOC_NR_ALTERNATE        := nDocNrAlternate,
               m_oDmsVer_MemGrid.CbPost(),
               endif,
         endif,
      next,
      m_oDmsVer_MemGrid.CbFirst(),
      if nNewDocID = 0 then
         // Versuchen, letzte Position wiederherzustellen
         bRecordFound := false,                                                    // WriteLn(nPreviousRecordID, nCurrentRecordID, nNextRecordID),
         if nCurrentRecordID <> -1 then
            bRecordFound := m_oDmsVer_MemGrid.CbLocate('ID', {nCurrentRecordID}, 0),  // WriteLn(bRecordFound),
         endif,
         if not bRecordFound and nPreviousRecordID <> -1 then
            bRecordFound := m_oDmsVer_MemGrid.CbLocate('ID', {nPreviousRecordID}, 0), // WriteLn(bRecordFound),
         endif,
         if not bRecordFound and nNextRecordID <> -1 then
            bRecordFound := m_oDmsVer_MemGrid.CbLocate('ID', {nNextRecordID}, 0),  //    WriteLn(bRecordFound, m_oDmsVer_MemGrid:ID, m_oDmsVer_MemGrid:DOC_NR),
         endif,
      else
         if not m_oDmsVer_Mask.CbNoDataAvailable then
            m_oDmsVer_MemGrid.CbLocate('ID', {nNewDocID}, 0),
         endif,
      endif,

      SyncMaskTableToGridTable(), // hier 1x notwendig, weil DisableControls...

   always
      DbEnableControls(m_oDmsVer_MemGrid),
   stopseq,
end,

//******************************************************************************
// Dokumenten-Tabelle entsprechend dem Master-Datensatz des Dockings
// synchronisieren => falls das nicht geht => Info-Panel anzeigen
// @Result: null
//******************************************************************************
function TryToSynchronizeDocumentTable(nNewDocID:=0)
| oRec, oDmsVer_FillMem |                                                       prs('TryToSynchronizeDocumentTable()', 'START'),

   if not empty(m_oDmsVer_Mask) and m_oDmsVer_Mask.Active then
      if not EditModes(m_oDmsVer_Mask) then
         // Sind keine Aktionen erlaubt => Tabelle per Scope leeren
         if m_bMasterTableIsInEditMode then
            m_nMasterIdOrArtNr := -1,
         else
            m_nMasterIdOrArtNr := DMSU_GetMasterIdOrArtNr(),
         endif,

         oDmsVer_FillMem                  := DbGetTable(m_oDM_Gui, waDmsVer, 'DMSVER_FILLMEM'),
         oDmsVer_FillMem.CheckReadAccess  := raFilter,  // Leserechte berücksichtigen
         oDmsVer_FillMem.CheckUserRights  := True,      // Berechtigungen prüfen
         oDmsVer_FillMem.IndexName        := 'WORKAREA',
         if m_nMasterWorkarea = waDab010 and gl_DMSU_ShowAllDocsForArtNr then
            oDmsVer_FillMem.IndexName     := 'WORKAREA_ARTNR',
         else
            oDmsVer_FillMem.IndexName     := 'WORKAREA',
         endif,
         startseq
            DbScope({m_nMasterWorkarea, m_nMasterIdOrArtNr},
                    {m_nMasterWorkarea, m_nMasterIdOrArtNr}, oDmsVer_FillMem),
                                                                                                                             
            if not empty(m_cContainsFilter) then
               DbFilter(m_cContainsFilter, oDmsVer_FillMem),
            endif,
            FillMemTable(oDmsVer_FillMem, nNewDocID), // füllt die Tabelle und stellt den letzten Datensatz-Zeiger wieder her, sofern möglich
         always
            // Filter + Scope wieder aufheben
            DbFilter(, oDmsVer_FillMem),
            DbScope(, oDmsVer_FillMem),
         stopseq,

         DMSU_CreateAndFillDokumentTree(),

         RefreshDevInfo(),
         ActionsEnabled(),

         bipnl_TableNotSynchronized.Visible := False,
      else
         bipnl_TableNotSynchronized.Visible := iif(m_nMasterWorkarea = waDab010 and gl_DMSU_ShowAllDocsForArtNr, m_nMasterIdOrArtNr <> m_oMasterTable:ARTNR, m_nMasterIdOrArtNr <> m_oMasterTable:ID), // Info-Warnung anzeigen, sofern die Dokumenten-Tabelle nicht synchron ist
      endif,
   endif,
end,

//******************************************************************************
// Diese Funktion überprüft, ob ein Post erlaubt auf die aktuelle Mastertabelle
// erlaubt ist.
// Dazu wird die Versionierungslogik auf REQ 787 überprüft
// @Result: boolean
//******************************************************************************
function DMSU_GUI_PostDocument_CheckPostAllowed()
   Result := true,
   if gl_DMSU_Param_StatusFGB_Logic = 2 then
      if cmb_DocumentApprovalState.Value = gl_DMSU_DokumentenStatusFGB_freigegeben and
         cmb_DocumentState.Value <> gl_DMSU_DokumentenStatus_aktuelleVersion and
         cmb_DocumentState.Value <> gl_DMSU_DokumentenStatus_Veraltet then
         MessageDlg("Ein freigebenes Dokument muss den Status 'aktuelle Version' oder 'veraltet' haben.", mtError),
         Result  := false,
      endif,
      if cmb_DocumentApprovalState.Value = gl_DMSU_DokumentenStatusFGB_gesperrt and
         cmb_DocumentState.Value = gl_DMSU_DokumentenStatus_aktuelleVersion then
         MessageDlg("Die aktuelle Version darf nicht gesperrt sein.", mtError),
         Result  := false,
      endif,
   endif,
end,

//******************************************************************************
// beantwortet die Frage, ob die Statusautomatik zum Tragen kommt.
// @Result: boolean
//******************************************************************************
function isStatusautomatik()
   | i |
   Result := false,
   if DbState(m_oDmsVer_Mask) = dsInsert and m_oDmsVer_Mask:VERS_NR > 1 then
      if gl_DMSU_Param_Status_NewVersion then
         result := true,
      else
         i := SeekInDimArray(m_oDmsVer_Mask:KATEGORIE, gl_DMSU_Param_Status_NewVersion_Kategorie, 1),
         if i > 0 then
            result := gl_DMSU_Param_Status_NewVersion_Kategorie[i, 2],
         endif,
      endif,
   endif,
end,

//******************************************************************************
//   REQ-787:
//   setzt den Status eines Dokuments gemäß Übergabeparameter
//   Im dem Fall, daß der Status auf "aktuelle Version" gesetzt wird,
//   werden alle Datensätze desselben Versionsstrag, die bis dato
//   auf "aktuelle Version" standen auf "veraltet" gesetzt
//******************************************************************************
function SetStatus( nStatus )                                                     // im Falle aktuelle Version die anderen Datensätze im Versionsstrang bearbeiten
| bWasEditMode |

    // ggf. erst in den Edit-Modus versetzen
    bWasEditMode := EditModes(m_oDmsVer_Mask),
    if not DbInTrans(m_oDM_Gui.ADSConnection) then
       DbStartTrans(m_oDM_Gui.ADSConnection),
    endif,

    if not bWasEditMode then
       DMSU_EditDocument(m_oDM_Gui, m_oDmsVer_Mask),                             // Info: die Dokumenten-Semaphore wird im Event 'BeforeEdit' gesetzt
    endif,
    m_oDmsVer_Mask:STATUS := nStatus,

    // im Falle aktuelle Version
    // - Timestamp und User merken
    // - alle alten aktuellen Versionen auf veraltet setzen
    if nStatus = gl_DMSU_DokumentenStatus_aktuelleVersion and gl_DMSU_Param_Status_Logic = 2 then
       m_oDmsVer_Mask:AKT_TS  :=  GetAdsServerTime(),
       m_oDmsVer_Mask:AKT_USR :=  c_usr,
       m_oDmsVerVersions                    := DbGetTable(m_oDM_Gui, waDmsVer, 'SEEK'),   // Eine Instanz der DmsVer die nicht auf den aktuellen Datensatz zeigt
       m_oDmsVerVersions.IndexName          := 'WORKAREA',

       DbScope({m_oDmsVer_Mask:WORKAREA, m_oDmsVer_Mask:DS_ID, m_oDmsVer_Mask:DOC_NR},
               {m_oDmsVer_Mask:WORKAREA, m_oDmsVer_Mask:DS_ID, m_oDmsVer_Mask:DOC_NR},
                m_oDmsVerVersions),
       DbGoTop(m_oDmsVerVersions),
       while not EoF(m_oDmsVerVersions) do
          if (m_oDmsVerVersions:VERS_NR <> m_oDmsVer_Mask:VERS_NR and m_oDmsVerVersions:STATUS = gl_DMSU_DokumentenStatus_aktuelleVersion)
             or isStatusAutomatik() then
              // Status auf veraltet ändern
              if not EditModes(m_oDmsVerVersions) then
                 DMSU_EditDocument(m_oDM_Gui, m_oDmsVerVersions),
                 m_oDmsVerVersions:STATUS := gl_DMSU_DokumentenStatus_Veraltet,
                 if gl_DMSU_Set_FBGStatus_like_Status then
                    m_oDmsVerVersions:STATUS_FGB := gl_DMSU_DokumentenStatusFGB_keineFreigabe,
                 endif,
                 m_bExplicitPost := True,
                 startseq
                    DMSU_PostDocument(m_oDM_Gui, m_oDmsVerVersions, false),
                 always
                    m_bExplicitPost := False,
                 stopseq,
              else
                 if DbInTrans(m_oDM_Gui.ADSConnection) then
                    DbRollback(m_oDM_Gui.ADSConnection),
                 endif,
                 meld('Datensatz in Bearbeitung'),
                 exit,
              endif,
          endif,
          DbSkip(m_oDmsVerVersions),
       end,
    endif,

    if not bWasEditMode then
       DMSU_PostDocument(m_oDM_Gui, m_oDmsVer_Mask, true),
       //DMSU_GUI_PostDocument(),
    endif,
    TryToSynchronizeDocumentTable(),
    ActionsEnabled(),
end,

//******************************************************************************
// Speichern eines Dokuments über die Oberfläche
// @Result: null
//******************************************************************************
function DMSU_GUI_PostDocument()
   | bSave |
   if DMSU_GUI_PostDocument_CheckPostAllowed() then
      bSave := true,
      writeln(m_oDmsVer_Mask:VERS_BEZ, m_oDmsVer_Mask:KATEG_ZUGR, cmb_DocumentAccessCategory.Value, edt_DocumentVersDesc.text),
      if not empty(cmb_DocumentAccessCategory.Value) then
         if not DMSU_CheckPermission_OPEN(cmb_DocumentAccessCategory.Value) then
            if messageDlg('Für diese Rechte Kategorie haben Sie kein OPEN-Recht. ' + crlf
                     + 'Wenn Sie jetzt speichern, werden Sie dieses Dokument weder bearbeiten noch öffnen können. ' + crlf
                     + 'Wollen Sie trotzdem speichern?', mtConfirmation, mbYes+mbNo) <> mrYes then
               bSave := false,
            endif,
         else
            if not DMSU_CheckPermission_WRITE(cmb_DocumentAccessCategory.Value) then
               if messageDlg('Für diese Rechte Kategorie haben Sie kein WRITE-Recht. ' + crlf
                        + 'Wenn Sie jetzt speichern, werden Sie dieses Dokument nicht bearbeiten können. ' + crlf
                        + 'Wollen Sie trotzdem speichern?', mtConfirmation, mbYes+mbNo) <> mrYes then
                  bSave := false,
               endif,
            endif,
         endif,
      endif,
      if bSave then
         // REQ 787 Automatik bei neuer Version für Status und Freigabestatus
         if isStatusautomatik() then
            SetStatus(gl_DMSU_DokumentenStatus_aktuelleVersion),
            if gl_DMSU_Set_FBGStatus_like_Status then
               m_oDmsVer_Mask:STATUS_FGB := gl_DMSU_DokumentenStatusFGB_Freigegeben,
            endif,
         endif,
         m_bExplicitPost := True,
         startseq
            DMSU_PostDocument(m_oDM_Gui, m_oDmsVer_Mask, true),
         always
            m_bExplicitPost := False,
         stopseq,
      endif,
   endif,
end,

//******************************************************************************
// Interne Funktion für die Neuanlage
// @Result: null
//******************************************************************************
function DMSU_GUI_AppendNewDocument(nDocType)
   m_bExplicitInsert := True,
   startseq
//      DMSU_AppendNewDocument(m_oDM_Gui, m_oDmsVer_Mask, nDocType, -1, -1, '', m_nMasterWorkarea, m_nMasterIdOrArtnr, m_cParamLastFolder),
      DMSU_AppendNewDocument(m_oDM_Gui, m_oDmsVer_Mask, nDocType, -1, -1, '', m_nMasterWorkarea, m_oMasterTable:ID, m_cParamLastFolder),
   always
      m_bExplicitInsert := False,
   stopseq,
   MyFocusControl(oForm, edt_DocumentName),
end,

//******************************************************************************
// Interne Funktion für die Anlage einer neuen Version zu einem bestehenden
// Dokument
// @Result: null
//******************************************************************************
function DMSU_GUI_AppendNewDocumentVersion()
   if DMSU_SemaphorEdit(m_oDmsVer_Mask:DOC_NR, True) then
      m_bExplicitInsert := True,
      startseq
         DMSU_AppendNewDocumentVersion(m_oDM_Gui, m_oDmsVer_Mask, m_oDmsVer_Mask:DOC_NR, True, m_cParamLastFolder),
      always
         m_bExplicitInsert := False,
      stopseq,
      MyFocusControl(oForm, edt_DocumentName),
   endif,
end,

//******************************************************************************
// Dialog: Eine Datei per Scan-Dialog in ein vorhandenes Dokument laden
// @Result: boolean "erfolgreich / abgebrochen"
//******************************************************************************
function LoadFileIntoDocumentViaScanDialog()
| oDocScanner, nSeite, oPage, cFileName |

   oDocScanner := CreateObject( 'TBeDocScanner', , oForm ),
   startseq
      oDocScanner.Options.Silence := 1,  // 0 = BE-Dialog UND Twain-Dialog des Treibers
                                         // 1 = nur BE-Dialog
                                         // 2 = kein Dialog
                                         // 3 = nur Twain-Dialog des Treibers

      oDocScanner.CbCanSaveAsMultiPageDocument := True,
      oDocScanner.ExecScan,

      // 4. Die Scans liegen jetzt in Form einer Collection-Liste vor und können abgeholt werden
      //    Wurde die Verarbeitung abgebrochen, ist die Liste leer
      for nSeite := 1 to CollCount(oDocScanner.StackOfScans) do

         oPage := CollItem(oDocScanner.StackOfScans, nSeite), // liefert eine Instanz der Klasse 'TBeDocScanItem'
         if oPage.CbSelected then
            startseq
               m_bExplicitInsert := True,
               startseq
                  DMSU_AppendNewDocument(m_oDM_Gui, m_oDmsVer_Mask, gl_DMSU_DokumentenArt_File, -1, -1, '', m_nMasterWorkarea, m_oMasterTable:ID, m_cParamLastFolder),
               always
                  m_bExplicitInsert := True,
               stopseq,
               DMSU_LoadScanPageIntoDocument(m_oDM_Gui, m_oDmsVer_Mask, oPage),
            onerror
               DMSU_CancelDocument(m_oDM_Gui, m_oDmsVer_Mask),
               Raise(),
            stopseq,
         endif,

      next,
   always
      DestroyObject(oDocScanner),
   stopseq,
end,

//******************************************************************************
// Dialog-Funktion zur Bestimmung des Datei-Links für ein Dokument
// @Result: boolean "erfolgreich / abgebrochen"
//******************************************************************************
function DefineFileLinkViaDialog()
| aOpenDlg, cFullFilePath, cLastUsedPath |
   Result := False,
   // Datei-Öffnen Dialog anzeigen
   cFullFilePath := '',
   cLastUsedPath := AllTrim(GetBeParam(m_cParamLastFolder + c_usr)),
   aOpenDlg      := OpenDlg('Datei-Link in Dokumentenmanagement definieren', '*.*', cLastUsedPath),
   startseq,
      aOpenDlg.Active := True,
      if aOpenDlg.Selected then
         cFullFilePath := aOpenDlg.FileName,
         SetBeParam(m_cParamLastFolder + c_usr, ExtractFilePath(cFullFilePath))
      endif,
   always,
      DestroyObject(aOpenDlg),
   stopseq,

   if not empty(cFullFilePath) then
      DMSU_SetNewFileLinkForDocument(m_oDM_Gui, m_oDmsVer_Mask, cFullFilePath),
      Result := True,
   endif,
end,

//******************************************************************************
// Dialog-Funktion zur Bestimmung des Hyperlinks für ein Dokument
// @Result: boolean "erfolgreich / abgebrochen"
//******************************************************************************
function DefineHyperLinkViaDialog()
| cOldHyperlink, cHyperLink, aHyperlink |
   Result := False,

   // aktuellen Hyperlink überschreiben?
   if not empty(m_oDmsVer_Mask:LINKS) then
      if not jn('Es ist bereits ein Hyperlink definiert, soll dieser überschrieben werden?') then
         exit,
      endif,
   endif,

   cOldHyperlink := AllTrim(m_oDmsVer_Mask:LINKS),
   //cHyperLink    := AllTrim(InputBox('Dokumentenmanagement', 'Hyperlink definieren', cOldHyperlink)),


   aHyperlink :=  DU_InputDialog(
      'Hyperlink definieren',
      'Bitte geben Sie den Hyperlink ein.',
      {
         DU_InputDialog_CreateInputControlDefinition('HYPERLINK',  'Hyperlink',   gl_DU_InputControlType_String,    '', 0,   cOldHyperlink, True)
      },
      {
         mrOk,
         mrCancel
      },
      {}
   ) ,
   if aHyperlink[1] = MrOk then
      cHyperlink :=  KVU_GET(aHyperlink[2],"HYPERLINK",""),
   else
      cHyperlink := cOldHyperlink,
   endif,

   // liegt eine Änderung vor?
   if cHyperLink <> cOldHyperlink then
      DMSU_SetNewHyperlinkForDocument(m_oDM_Gui, m_oDmsVer_Mask, cHyperLink),
      Result := True,
   endif,
end,

//******************************************************************************
// Einstellungen laden
// @Result: null
//******************************************************************************
function LoadSettings()
| aSettings, aSplitterTree, cSaveKey |
   cSaveKey  := 'DMS' + StrZero(m_nMasterWorkarea, 3) + c_usr,
   startseq
      aSettings     := StrToArr(GetBeParam(cSaveKey)),
      aSplitterTree := KVU_Get(aSettings, 'PANEL_TREE', {}),
      GU_TBePanel_SetSplitterData(pnl_LeftTree, aSplitterTree),
   onerror
      // Kein fataler Fehler -> Exceptions ignorieren
   stopseq,
end,

//******************************************************************************
// Einstellungen speichern
// @Result: null
//******************************************************************************
function SaveSettings()
   | cSaveKey, aSettings |
   cSaveKey  := 'DMS' + StrZero(m_nMasterWorkarea, 3) + c_usr,
   startseq
      aSettings := {},
      KVU_Set(aSettings, 'PANEL_TREE', GU_TBePanel_GetSplitterData(pnl_LeftTree)),
      SetBeParam(cSaveKey, ArrToStr(aSettings)),
   onerror
      // Kein fataler Fehler -> Exceptions ignorieren
      GU_ShowStdErrorMessage('Fehler beim Speichern der Fenster-Einstellungen', GetErrorObj()),
   stopseq,
end,

//##############################################################################
//##############################################################################
// Eventhandler
//##############################################################################
//##############################################################################

//******************************************************************************
// Event: Doppelklick auf File oder File- oder Hyper-Link im Browser => öffnen
//******************************************************************************
function grd_MainDblClick( Sender )                                             prs('grd_MainDblClick', 'START'),
   case m_oDmsVer_MemGrid:ART
      of gl_DMSU_DokumentenArt_File      :: ActionExecute(A_OpenFileDocument),
      of gl_DMSU_DokumentenArt_Filelink  :: ActionExecute(A_OpenFileOrHyperlink),
      of gl_DMSU_DokumentenArt_Hyperlink :: ActionExecute(A_OpenFileOrHyperlink),
   endcase,                                                                     prs('grd_MainDblClick', 'ENDE'),
end,

//******************************************************************************
// Event: Nach Umschalten des Supervisor-Modus
//******************************************************************************
function FormExAfterAdminModeChange( Sender )                                   prs('FormExAfterAdminModeChange', 'START'),
   ActionsEnabled(),                                                            prs('FormExAfterAdminModeChange', 'ENDE'),
end,

//******************************************************************************
// Event: Nach dem Andocken des Fensters
//******************************************************************************
function FormExEndDock( Sender )
| oParent |
   // Hilfs-Methode, die der Ziel-Tabkarte das Image des Fensters zuweist
                                                                                prs('FormExEndDock', 'START'),
   oParent := GetParent(oForm),
   if not empty(oParent) then
      if ClassName(oParent) = 'TTabSheet' then
         oParent.ImageIndex := oForm.ImageIndex,
         oParent.Caption    := StrTran(oForm.Caption, '&', '&&'),
      endif,
   endif,                                                                       prs('FormExEndDock', 'ENDE'),
end,

//******************************************************************************
// Event: Beim Schließen des Formulars
//******************************************************************************
function FormExClose( Sender, Action)                                           prs('Dokumente Docking => FormExClose', 'START'),
   Action := caFree,                                                            prs('FormExClose', 'ENDE'),
end,

//******************************************************************************
// Event: Beim Zerstören des Formulars
//******************************************************************************
function FormExDestroy( Sender )                                                prs('Dokumente Docking => FormExDestroy', 'START'),
   GFU_DockingForm_Destroyed(oForm, m_cFormRefKey),                             prs('Dokumente Docking => FormExDestroy', 'END'),
   SaveSettings(),
end,

//******************************************************************************
// Event: Klick auf das InfoPanel "Tabelle nicht synchronisiert"
//******************************************************************************
function bipnl_TableNotSynchronizedClick( Sender )                              prs('bipnl_TableNotSynchronizedClick', 'START'),
   if EditModes(m_oDmsVer_Mask) then
      MessageDlg('Die Dokumententabelle kann aktuell nicht synchronisert werden, da ' +
                 'sich der angezeigte Datensatz im Bearbeitungsmodus befindet.'),
   else
      TryToSynchronizeDocumentTable(),
   endif,                                                                       prs('bipnl_TableNotSynchronizedClick', 'ENDE'),
end,

//******************************************************************************
// Event: Fenster soll geschlossen werden => ggf. vorhandene Änderung verwerfen
//******************************************************************************
function FormExCloseQuery( Sender, bCanClose )                                  prs('FormExCloseQuery', 'START'),
   if EditModes(m_oDmsVer_Mask) then
      bCanClose := JN('Dokumentenmanagement: ' + crlf +
                      'Änderungen am Dokument "' + AllTrim(m_oDmsVer_Mask:NAME) + '" verwerfen?'),
      if bCanClose then
         DMSU_CancelDocument(m_oDM_Gui, m_oDmsVer_Mask),
      endif,
   endif,                                                                       prs('FormExCloseQuery', 'ENDE'),
end,

//******************************************************************************
// Event: Beim AutoEdit über die Maske muss die Dokumenten-Sperre geprüft und
//        gesetzt werden
//******************************************************************************
function DMSVER_Mask_BeforeEdit()
| nDocNo |
   // Sind gerade keine Aktionen erlaubt, dann muss der Edit abgebrochen werden.
   // Siehe HandleSemaphorTableStateChanges()
                                                                                  prs('DMSVER_Mask_BeforeEdit', 'START'),
   if m_bMasterTableIsInEditMode then
      StatusError('Fehler wegen gleichzeitiger Bearbeitung des Dokumenten - und des MasterDatensatzes'),
      Abort(True),
   endif,

   // endgültig gelöscht (Datensatz ist inzwischen nicht mehr da - anderer User hat ihn gelöscht)
   if Lookup(waDMSVER, 'ID', {{m_oDmsVer_Mask:ID}}, 'ID',0) = 0 then
      StatusError('Das Dokument wurde endgültig gelöscht. Der Browser wird aktualisiert'),
      TryToSynchronizeDocumentTable(),
      Abort(True),
   endif,

// Diesen Code darf man nicht verwenden, weil beim reaktivieren auch der Edit-Modus
// benötigt wird und da darf dieser Abort nicht stattfinden
//   // "gelöscht" markiert
//   if (not empty(Lookup(waDMSVER, 'ID', {{m_oDmsVer_Mask:ID}}, 'LOESCH_USR','FEHLER')) ) then
//      StatusError('Dieses Dokument wurde gelöscht. Bitte aktualisieren Sie den Browser!'),
//      Abort(True),
//   endif,

   // kein Lese-Recht
   if not DMSU_CheckPermission_READ(Lookup(waDMSVER, 'ID', {{m_oDmsVer_Mask:ID}}, 'KATEG_ZUGR', 0,,,, true)) then
      StatusError('Sie haben keine ausreichenden Rechte. Bitte aktualisieren Sie ggf. den Browser!'),
      Abort(True),
   endif,

   // kein Schreibrecht
   if not DMSU_CheckPermission_WRITE(Lookup(waDMSVER, 'ID', {{m_oDmsVer_Mask:ID}}, 'KATEG_ZUGR',0)) then
      StatusError('Sie haben keine ausreichenden Rechte. Bitte aktualisieren Sie ggf. den Browser!'),
      Abort(True),
   endif,

   nDocNo := m_oDmsVer_Mask:DOC_NR,
   if not DMSU_SemaphorEdit(nDocNo, True) then
      StatusError('Eine Version dieses Dokuments ist anderweitig in Bearbeitung. Bitte aktualisieren Sie ggf. den Browser!'),
      Abort(True),
   endif,                                                                       prs('DMSVER_Mask_BeforeEdit', 'ENDE'),
end,

//******************************************************************************
// Event: Eine Neuanlage muss verhindert werden, wenn derzeit keine Aktionen
//        erlaubt sind. Siehe HandleSemaphorTableStateChanges()
// @Result: null
//******************************************************************************
function DMSVER_Mask_BeforeInsert()                                             prs('DMSVER_Mask_BeforeInsert', 'START'),
   if m_bMasterTableIsInEditMode then
      Abort(True),
   endif,

   if not m_bExplicitInsert then
      Abort(True),
   endif,                                                                       prs('DMSVER_Mask_BeforeInsert', 'ENDE'),
end,

//******************************************************************************
// Event: Beim (warum auch immer vorkommenden) "unkontrollierten" Abbruch muss
//        die Dokumentensperre aufgehoben werden.
//        (Ein kontrollierter Abbruch würde DMS_CancelDocument() direkt aufrufen)
//******************************************************************************
function DMSVER_Mask_AfterCancel()                                              prs('DMSVER_Mask_AfterCancel', 'START'),
   DMSU_CancelDocument(m_oDM_Gui, m_oDmsVer_Mask),                              prs('DMSVER_Mask_AfterCancel', 'ENDE'),
end,

//******************************************************************************
// Event: Verhindern, dass die Dokumenten-Tabelle neu positioniert wird solange
//        ein Dokument sich in Bearbeitung befindet
// @Result: null
//******************************************************************************
function DMSVER_Mask_BeforePost( Sender )                                       prs('DMSVER_Mask_BeforePost', 'START'),
   if not m_bExplicitPost then
      Abort(True),
   endif,                                                                       prs('DMSVER_Mask_BeforePost', 'ENDE'),
end,

//******************************************************************************
// Event: Verhindern, dass die Dokumenten-Memtable des Grids neu positioniert wird solange
//        ein Dokument sich in Bearbeitung befindet
// @Result: null
//******************************************************************************
function DMSVER_MemGrid_BeforeScroll( Sender )                                  prs('DMSVER_MemGrid_BeforeScroll', 'START'),
   if EditModes(m_oDmsVer_Mask) then
      Abort(True),
   endif,                                                                       prs('DMSVER_MemGrid_BeforeScroll', 'ENDE'),
end,

//******************************************************************************
// Event: Klick auf das Dev-Info-Panel
//******************************************************************************
function bipnl_DevInfosClick( Sender )                                          prs('bipnl_DevInfosClick', 'START'),
   ShellExecute(DMSU_CalcUserTempPath(c_usr)),                                  prs('bipnl_DevInfosClick', 'ENDE'),
end,

//******************************************************************************
// Event: beim Panel-Resize: Breite des Dokumenten-Namen-Edits anpassen
//******************************************************************************
function pnl_MaskTopAreaResize( Sender )                                        prs('pnl_MaskTopAreaResize', 'START'),
   edt_DocumentName.Width := pnl_MaskTopArea.Width - 10,                        prs('pnl_MaskTopAreaResize', 'ENDE'),
end,

//******************************************************************************
// Event: Doppelklick auf File- oder Hyper-Link => öffnen
//******************************************************************************
function edt_FileOrHyperLinkDblClick( Sender )                                  prs('edt_FileOrHyperLinkDblClick', 'START'),
   if A_OpenFileOrHyperlink.Enabled then
      DMSU_GUI_ShellExecuteWithWaitEffekt(m_oDmsVer_Mask:LINKS, True, True),
   endif,                                                                       prs('edt_FileOrHyperLinkDblClick', 'ENDE'),
end,

//******************************************************************************
// Event: Scroll der Dokumenten-Tabelle
//******************************************************************************
function ds_Documents_GridScroll_Update( Sender )                               prs('ds_Documents_GridScroll_Update', 'START'),
   SyncMaskTableToGridTable(),                                                  prs('ds_Documents_GridScroll_Update', 'ENDE'),
end,

//******************************************************************************
// Event: StateChange der Dokumenten-Tabelle
//******************************************************************************
function ds_Documents_MaskStateChange( Sender )                                 prs('ds_Documents_MaskStateChange', 'START'),
   // Aktionen auf der Master-Tabelle En-/Disablen, wenn die Dokumententabelle
   // bearbeitet/gespeichert wird.
   if EditModes(m_oDmsVer_Mask) then
      if not DbInTrans(m_oDM_Gui.ADSConnection) then                             // die Transaktion nicht nochmals auslösen falls diese bereits über den Append ausgelöst wurde
         DbStartTrans(m_oDM_Gui.ADSConnection),
      endif,
      if not m_oMasterTable.CbIsNoRecordMove() then
         m_oMasterTable.CbBeginNoRecordMove(),
      endif,
   else
      if m_oMasterTable.CbIsNoRecordMove() then
         m_oMasterTable.CbEndNoRecordMove(),
      endif,
   endif,

   ActionsEnabled(),                                                            prs('ds_Documents_MaskStateChange', 'ENDE'),
end,

//******************************************************************************
// Diese Funktion behandelt den Sonderfall, einer TBeSemaphoreTable als
// MasterTable.
// Semaphor-Tabellen tauschen die echte Tabelle bei einem Edit/Insert durch eine
// MemTable aus. Daher wird das Docking nicht korrekt aktualisiert.
// Um sämtliche Aktionen mit dieser temporären Memtable zu Verhindern, wird mit
// dem m_bMasterTableIsInEditMode-Flag dafür gesorgt, dass keine Aktionen mehr über die
// Oberfläche möglich sind.
// Die Prüfung ob dieses Flag gesetzt werden muss lässt sich über das
// Parent-DataSource prüfen indem dessen DataSet mit der MasterTable verglichen
// wird. Sind die Instanzen nicht gleich wird das Flag gesetzt!
//******************************************************************************
function HandleSemaphorTableStateChanges()
| oMasterDataSource, oCurrentDataSet |
   startseq
      result := False,
      if not empty(m_oMasterTable) then
         oMasterDataSource := m_oMasterTable.DataSource,
         if not empty(oMasterDataSource) then
            oCurrentDataSet := oMasterDataSource.DataSet,
            if not empty(oCurrentDataSet) then
               // Unterscheiden sich die DataSets voneinander? Und ist eine von
               // beiden im Insert-Modus so werden alle Aktionen an der Oberfläche
               // unterbunden
               if m_oMasterTable <> oCurrentDataSet and
                  (EditModes(oCurrentDataSet) or EditModes(m_oMasterTable)) then
                  result := True, // Keine Actions erlauben!
               endif,
            endif,
         endif,
      endif,
   onerror
      GU_ShowStdErrorMessage('Fehler in Semaphortabellenhandling', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Event: Beim Wechsel des Status des Master-DataSource
//******************************************************************************
function ds_MainTableStateChange( Sender )                                      prs('ds_MainTableStateChange', 'START'),
   m_bMasterTableIsInEditMode := false,
   if m_oMasterTable.Workarea = waDAB010 or m_oMasterTable.Workarea = waDAB000 or m_oMasterTable.Workarea = waDAB100 then
      m_bMasterTableIsInEditMode := HandleSemaphorTableStateChanges(),
   else
      if EditModes(m_oMasterTable) then
         m_bMasterTableIsInEditMode := True,
      endif,
   endif,

   TryToSynchronizeDocumentTable(),                                             prs('ds_MainTableStateChange', 'ENDE'),
end,

//******************************************************************************
// Event: Beim Scroll des Master-DataSource
//******************************************************************************
function ds_MainTableScroll_Update( Sender )                                    prs('ds_MainTableScroll_Update', 'START'),
   m_bMasterTableIsInEditMode := false,
   if m_oMasterTable.Workarea = waDAB010 or m_oMasterTable.Workarea = waDAB000 or m_oMasterTable.Workarea = waDAB100 then
      m_bMasterTableIsInEditMode := HandleSemaphorTableStateChanges(),
   else
      if EditModes(m_oMasterTable) then
         m_bMasterTableIsInEditMode := True, // Keine Actions erlauben, auch für Nicht-SemaphorenTabelle!

      endif,
   endif,

   TryToSynchronizeDocumentTable(),
   edt_searchText.text := '',                                                   prs('ds_MainTableScroll_Update', 'ENDE'),
end,

//******************************************************************************
// Event: Merkt sich welche Kategorie im Tree gewählt wurde
// @Result: null
//******************************************************************************
function OnTreeViewClick(Sender)
| oSelectedNode |
                                                                                prs('OnTreeViewClick', 'START'),
   if not Empty(m_oTree.Selected) and ClassOf(m_oTree.Selected, 'TTreeNodeEx') then
      oSelectedNode       := m_oTree.Selected,
      m_nKategorienFilter := Val(oSelectedNode.Value),
   endif,
   TryToSynchronizeDocumentTable(),                                             prs('OnTreeViewClick', 'ENDE'),
end,

//##############################################################################
//##############################################################################
// Actionhandler
//##############################################################################
//##############################################################################

//******************************************************************************
//  Schreibt Datum und User ins memo-Feld
//******************************************************************************
function a_DatumUserExecute( Sender )
   startseq
      GWU_InsertDatumUserIntoRTF('MEMO', m_oDmsVer_Mask, richedit_DocumentMemo),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Einfügen von Datum und User ins Memofeld', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//  REQ 839: nach Änderung des Statusfilters
//******************************************************************************
function SelectBoxChange( Sender )
   startseq
      if empty(oSelectBox.SelectedAsIDString) then
         oSelectBox.CbCheckItem(1),
      endif,
      TryToSynchronizeDocumentTable(),
   onerror
      GU_ShowStdErrorMessage('Fehler nach Änderung des Statusfilters', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//  REQ 820: Volltextsuche
//******************************************************************************
function edt_SearchTextSearchExecute( Sender )
| cInputText |
   Startseq
      cInputText := edt_SearchText.Text,
      if empty(cInputText) then
         m_cContainsFilter := '',
      else
         m_cContainsFilter := PrepareTextForFTSSearch( waDMSVER, 'SUCHE',
                                                       cInputText,  '',
                                                       false, true,
                                                      'AND', True ),
      endif,
      TryToSynchronizeDocumentTable(),
   onerror
      GU_ShowStdErrorMessage('Fehler bei der Volltextsuche', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//    Aktualisiert den Browser
//    nützlich, wenn z.B. ein anderer User ein Dokument gelöscht hat
//******************************************************************************
function A_RefreshExecute( Sender )
   Startseq
      TryToSynchronizeDocumentTable(),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Aktualisieren des Browsers', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//    Sprung zum RABAC Fenster für Zugriffsberechtigungen
//******************************************************************************
function a_ZugriffsberechtigungExecute( Sender )
   startseq
      ShowBeWindow(bwParameterAdministration, '33;' +  gl_DMSU_cRightsClassID),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Sprung zum RABAC Fenster für Zugriffsberechtigungen', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//   REQ-787:
//   setzt den Status eines Dokuments auf "veraltet"
//   Das hat keinerlei Auswirkungen auf den Status anderer Versionen
//******************************************************************************
function A_StatusVeraltetExecute( Sender )
   startseq
      SetStatus(gl_DMSU_DokumentenStatus_Veraltet),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Setzen des Status auf: "veraltet"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//   REQ-787:
//   setzt den Status eines Dokuments auf "aktuelle Version"
//   Alle bisherigen "aktuellen Versionen" im Versionsstrang
//   werden auf "veraltet" gesetzt
//******************************************************************************
function A_StatusAktuelleVersionExecute( Sender )
   startseq
       SetStatus(gl_DMSU_DokumentenStatus_aktuelleVersion),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Setzen des Status auf: "aktuelle Version"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//   REQ-787:
//   setzt den Status eines Dokuments auf "in Bearbeitung"
//   Das hat keinerlei Auswirkungen auf den Status anderer Versionen
//******************************************************************************
function A_StatusInBearbeitungExecute( Sender )
   startseq
      SetStatus(gl_DMSU_DokumentenStatus_inBearbeitung),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Setzen des Status auf: "in Bearbeitung"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//   REQ-787:
//   setzt den Status eines Dokuments auf "zur Überprüfung"
//   Das hat keinerlei Auswirkungen auf den Status anderer Versionen
//******************************************************************************
function A_StatusZurUeberpruefungExecute( Sender )
   startseq
      SetStatus(gl_DMSU_DokumentenStatus_zurUeberpruefung),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Setzen des Status auf: "zur Ueberpruefung"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Datei-Dokument öffnen (muss hierfür vorher lokal gespeichert werden)
//******************************************************************************
function A_OpenFileDocumentExecute( Sender )
| cLocalFileName |
   startseq
      cLocalFileName := DMSU_LoadDocumentToLocalTempFolder(m_oDM_Gui, m_oDmsVer_Mask, DMSU_CalcUserTempPath(c_usr), false),     // writeln(cLocalFileName),
      if not empty(cLocalFileName) then
         DMSU_GUI_ShellExecuteWithWaitEffekt(cLocalFileName, False, True),
      endif,
   onerror
      GU_ShowStdErrorMessage('Fehler beim Öffnen einer Datei', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Datei-Dokument über einen Dialog speichern
//******************************************************************************
function A_SaveFileExecute( Sender )
   startseq
      DMSU_SaveDocumentWithSaveDialog(m_oDM_Gui, m_oDmsVer_Mask),
   onerror
      GU_ShowStdErrorMessage('Fehler bei "Datei-Dokument über einen Dialog speichern"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Datei-Link bzw. Hyperlink öffnen
//******************************************************************************
function A_OpenFileOrHyperlinkExecute( Sender )
   startseq
      DMSU_GUI_ShellExecuteWithWaitEffekt(m_oDmsVer_Mask:LINKS, True, True),
   onerror
      GU_ShowStdErrorMessage('Fehler bei: "Datei-Link bzw. Hyperlink öffnen"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Für einen bereits exist. Dokumenten-Datensatz den "Inhalt" neu
//         definieren - je nach Art
//******************************************************************************
function A_LoadFileOrDefineLinkExecute( Sender )
| bWasEditMode, aCancelled |
   startseq
      aCancelled := True,
      // ggf. erst in den Edit-Modus versetzen
      bWasEditMode := EditModes(m_oDmsVer_Mask),
      if not bWasEditMode then
         if not DbInTrans(m_oDM_Gui.ADSConnection) then
            DbStartTrans(M_oDM_Gui.ADSConnection),
         endif,
         DMSU_EditDocument(m_oDM_Gui, m_oDmsVer_Mask),                          // Info: die Dokumenten-Semaphore wird im Event 'BeforeEdit' gesetzt
      endif,

      case m_oDmsVer_Mask:ART
        of gl_DMSU_DokumentenArt_File      :: aCancelled := not DMSU_LoadFileIntoDocumentViaDialog(m_oDM_Gui, m_oDmsVer_Mask, m_cParamLastFolder),
        of gl_DMSU_DokumentenArt_Filelink  :: aCancelled := not DefineFileLinkViaDialog(),
        of gl_DMSU_DokumentenArt_Hyperlink :: aCancelled := not DefineHyperLinkViaDialog(),
      endcase,

      if aCancelled and not bWasEditMode then
         DMSU_CancelDocument(m_oDM_Gui, m_oDmsVer_Mask),
      endif,
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang "Datei oder Link ersetzen"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// REQ 816: Action: Neues Dokument der Art "Datei"
//******************************************************************************
function A_NewDocumentExecute( Sender )
   startseq
      DMSU_GUI_AppendNewDocument(gl_DMSU_DokumentenArt_File),
      if not DMSU_LoadFileIntoDocumentViaDialog(m_oDM_Gui, m_oDmsVer_Mask, m_cParamLastFolder) then
         DMSU_CancelDocument(m_oDM_Gui, m_oDmsVer_Mask),
      endif,
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang: "Anlegen eines neuen Dokuments"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Neues Dokument der Art "Datei" per Scan erstellen
//******************************************************************************
function A_NewFileScanExecute( Sender )
   startseq
      LoadFileIntoDocumentViaScanDialog(),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang: "Anlegen eines neuen Dokuments durch Scan"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Neues Dokument der Art "File-Link"
//******************************************************************************
function A_NewFilelinkExecute( Sender )
   startseq
      DMSU_GUI_AppendNewDocument(gl_DMSU_DokumentenArt_Filelink),
      DefineFileLinkViaDialog(),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang: "Anlegen eines neuen Datei-Links"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Neues Dokument der Art "Hyperlink"
//******************************************************************************
function A_NewHyperlinkExecute( Sender )
   startseq
      DMSU_GUI_AppendNewDocument(gl_DMSU_DokumentenArt_Hyperlink),
      DefineHyperLinkViaDialog(),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang: "Anlegen eines neuen Hyperlinks"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Neue Version zum aktuellen Dokument anlegen
//******************************************************************************
function A_NewVersionExecute( Sender )
   startseq
      DMSU_GUI_AppendNewDocumentVersion(),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang: "Anlegen einer neuen Version"', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Datensatz speichern
//******************************************************************************
function A_SaveExecute( Sender )
   startseq
      DMSU_GUI_PostDocument(),
      TryToSynchronizeDocumentTable(m_oDmsVer_Mask:ID),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Speichern', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// Action: Bearbeitung abbrechen
//******************************************************************************
function A_CancelExecute( Sender )
   startseq
      if JN('Änderungen verwerfen?') then
         DMSU_CancelDocument(m_oDM_Gui, m_oDmsVer_Mask),
         ActionsEnabled(),
      endif,
   onerror
      GU_ShowStdErrorMessage('Fehler beim Cancel', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//  REQ: 805
//  Dokument löschen, d.h. Dokument wird als gelöscht markiert durch Füllen der
//  Felder DMSVER:GELOESCHT und DMSVER:LOESCH_USR
//******************************************************************************
function A_DeleteExecute( Sender )
   | bWasEditMode |
   startseq
      // ggf. erst in den Edit-Modus versetzen
      bWasEditMode := EditModes(m_oDmsVer_Mask),

      if not DbInTrans(m_oDM_Gui.ADSConnection) then
         DbStartTrans(m_oDM_Gui.ADSConnection),
      endif,
      if not bWasEditMode then
         DMSU_EditDocument(m_oDM_Gui, m_oDmsVer_Mask),                          // Info: die Dokumenten-Semaphore wird im Event 'BeforeEdit' gesetzt
      endif,

      DMSU_DeleteDocument(m_oDmsVer_Mask),

      if not bWasEditMode then
         DMSU_GUI_PostDocument(),
      endif,
      TryToSynchronizeDocumentTable(),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler beim (temporären) Löschen eines Dokuments', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//  REQ: 805
//  Dokument reaktivieren durch Leeren der
//  Felder DMSVER:GELOESCHT und DMSVER:LOESCH_USR
//******************************************************************************
function a_reactivateExecute( Sender )
   | bWasEditMode |
   startseq
      // ggf. erst in den Edit-Modus versetzen
      bWasEditMode := EditModes(m_oDmsVer_Mask),
      if not DbInTrans(m_oDM_Gui.ADSConnection) then
         DbStartTrans(m_oDM_Gui.ADSConnection),
      endif,

      if not bWasEditMode then
         DMSU_EditDocument(m_oDM_Gui, m_oDmsVer_Mask),                         // Info: die Dokumenten-Semaphore wird im Event 'BeforeEdit' gesetzt
      endif,

      DMSU_ReactivateDocument(m_oDmsVer_Mask),
      if not bWasEditMode then
         DMSU_GUI_PostDocument(),
      endif,
      TryToSynchronizeDocumentTable(),
      ActionsEnabled(),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Reaktivieren eines gelöschten Datensatzes', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
//    REQ-831: DMS (GUI): "Dokumente" Docking - auch gelöschte anzeigen
//    ändert den Zustand der globalen Variablen
//    ändert die Hintergrundfarbe des Buttons
//******************************************************************************
function a_showDeletedExecute( Sender )
   startseq
      a_showDeleted.Checked := not a_showDeleted.Checked,
      TryToSynchronizeDocumentTable(),
   onerror
      GU_ShowStdErrorMessage('Fehler beim Ändern des Zustands, ob auch gelöschte angezeigt werden sollen', GetErrorObj()),
   stopseq,
end,

//******************************************************************************
// REQ 805:
// Action: Dokument löschen
//******************************************************************************
function A_DeleteEndgueltigExecute( Sender )
| nDeleteDocNo |
   startseq
      nDeleteDocNo := m_oDmsVer_Mask:DOC_NR,
      if JN('Datensatz löschen?') then
         DMSU_DeleteEndgueltigDocument(m_oDM_Gui, m_oDmsVer_Mask, nDeleteDocNo),
         TryToSynchronizeDocumentTable(),
      endif,
   onerror
      GU_ShowStdErrorMessage('Fehler im Vorgang: "endgültig Löschen"', GetErrorObj()),
   stopseq,
end,

//##############################################################################
//##############################################################################
// Oberflächen-Funktionen
//##############################################################################
//##############################################################################

//******************************************************************************
// InitForm lädt das Formular in Abhängigkeit des Owners
// @Result: null
//******************************************************************************
function InitForm()                                                             prs('InitForm', 'START'),
   if empty(m_oOwnerForm) then
      oForm             := LoadForm( m_cFormClassID, Application),
      oForm.BorderStyle := bsSizeable,
   else
      oForm             := LoadForm( m_cFormClassID, m_oOwnerForm),
      oForm.BorderStyle := bsSizeToolWin, // wichtig für die Dockbarkeit
   endif,

   oForm.Name           := GFU_CalcFormularName(m_cFormRefKey, oForm, m_oOwnerForm),
   oForm.OrigCapt       := 'Dokumente',
   oForm.PositionSaveID := m_cPositionSaveId,                                   prs('InitForm', 'ENDE'),
end,

//******************************************************************************
// Standard-Einstellungen setzen
// @Result: null
//******************************************************************************
function SetDefaults()                                                          prs('SetDefaults', 'START'),
   oForm.ImageIndex                        := 426,   // Für den Fenster-Navigator und Tabkarten-Symbole
   edt_FileOrHyperLink.BorderStyle         := bsNone,
   edt_FileOrHyperLink.Cursor              := crHandPoint,
   pnl_Mask.Constraints.MinWidth           := 50,
   pnl_Mask.Width                          := 360,
   bipnl_DevInfos.Visible                  := False, // Info-Panel für die Anzeige des aktuellen Master-Datensatzes
   edt_SearchText.Text                     := '',
   bipnl_NoActionForSemaphorInsert.Visible := False,
   m_nKategorienFilter                     := 0,                                prs('SetDefaults', 'ENDE'),

   m_nMasterIdOrArtNr                      := DMSU_GetMasterIdOrArtNr(),
end,


//******************************************************************************
// LoadGUI lädt sämtliche Komponenten die für die Oberfläche benötigt werden.
// @Result: null
//******************************************************************************
function LoadGUI()                                                              prs('LoadGUI', 'START'),
   startseq
      // @VZB@ der nachfolgende Teil wird automatisch gepflegt
      A_AktiveAnzeigen                := FindObject(oForm, "A_AktiveAnzeigen"),
      A_Cancel                        := FindObject(oForm, "A_Cancel"),
      a_DatumUser                     := FindObject(oForm, "a_DatumUser"),
      A_Delete                        := FindObject(oForm, "A_Delete"),
      A_DeleteEndgueltig              := FindObject(oForm, "A_DeleteEndgueltig"),
      A_KuenftigeAnzeigen             := FindObject(oForm, "A_KuenftigeAnzeigen"),
      A_LoadFileOrDefineLink          := FindObject(oForm, "A_LoadFileOrDefineLink"),
      A_NewDocument                   := FindObject(oForm, "A_NewDocument"),
      A_NewFilelink                   := FindObject(oForm, "A_NewFilelink"),
      A_NewFileScan                   := FindObject(oForm, "A_NewFileScan"),
      A_NewHyperlink                  := FindObject(oForm, "A_NewHyperlink"),
      A_NewVersion                    := FindObject(oForm, "A_NewVersion"),
      A_OpenFileDocument              := FindObject(oForm, "A_OpenFileDocument"),
      A_OpenFileOrHyperlink           := FindObject(oForm, "A_OpenFileOrHyperlink"),
      a_reactivate                    := FindObject(oForm, "a_reactivate"),
      A_Refresh                       := FindObject(oForm, "A_Refresh"),
      A_Save                          := FindObject(oForm, "A_Save"),
      A_SaveFile                      := FindObject(oForm, "A_SaveFile"),
      a_showDeleted                   := FindObject(oForm, "a_showDeleted"),
      A_StatusAktuelleVersion         := FindObject(oForm, "A_StatusAktuelleVersion"),
      A_StatusInBearbeitung           := FindObject(oForm, "A_StatusInBearbeitung"),
      A_StatusVeraltet                := FindObject(oForm, "A_StatusVeraltet"),
      A_StatusZurUeberpruefung        := FindObject(oForm, "A_StatusZurUeberpruefung"),
      A_VeralteteAnzeigen             := FindObject(oForm, "A_VeralteteAnzeigen"),
      A_Zugriffsberechtigung          := FindObject(oForm, "A_Zugriffsberechtigung"),
      Actions                         := FindObject(oForm, "Actions"),
      BeBarButton1                    := FindObject(oForm, "BeBarButton1"),
      BeBarDockControl1               := FindObject(oForm, "BeBarDockControl1"),
      BeBarDockControl2               := FindObject(oForm, "BeBarDockControl2"),
      BeBarDockControlDeleteButton    := FindObject(oForm, "BeBarDockControlDeleteButton"),
      BeBarManager                    := FindObject(oForm, "BeBarManager"),
      BeBarManagerBar1                := FindObject(oForm, "BeBarManagerBar1"),
      BeBarManagerBar2                := FindObject(oForm, "BeBarManagerBar2"),
      BeBarManagerBar4                := FindObject(oForm, "BeBarManagerBar4"),
      BeBarManagerStatusBar1          := FindObject(oForm, "BeBarManagerStatusBar1"),
      BeBarSeparator1                 := FindObject(oForm, "BeBarSeparator1"),
      BeBarSubItem1                   := FindObject(oForm, "BeBarSubItem1"),
      Bevel1                          := FindObject(oForm, "Bevel1"),
      Bevel2                          := FindObject(oForm, "Bevel2"),
      bipnl_DevInfos                  := FindObject(oForm, "bipnl_DevInfos"),
      bipnl_NoActionForSemaphorInsert := FindObject(oForm, "bipnl_NoActionForSemaphorInsert"),
      bipnl_TableNotSynchronized      := FindObject(oForm, "bipnl_TableNotSynchronized"),
      btn_datumUser                   := FindObject(oForm, "btn_datumUser"),
      btn_delete                      := FindObject(oForm, "btn_delete"),
      btn_LoadFileOrDefineLink_File   := FindObject(oForm, "btn_LoadFileOrDefineLink_File"),
      btn_LoadFileOrDefineLink_Link   := FindObject(oForm, "btn_LoadFileOrDefineLink_Link"),
      btn_loeschen                    := FindObject(oForm, "btn_loeschen"),
      btn_OpenFileDocument            := FindObject(oForm, "btn_OpenFileDocument"),
      btn_OpenFileOrHyperlink         := FindObject(oForm, "btn_OpenFileOrHyperlink"),
      btn_reactivate                  := FindObject(oForm, "btn_reactivate"),
      btn_refresh                     := FindObject(oForm, "btn_refresh"),
      btn_SaveDocumentFile            := FindObject(oForm, "btn_SaveDocumentFile"),
      btn_SaveLinkFile                := FindObject(oForm, "btn_SaveLinkFile"),
      btn_ShowDeleted                 := FindObject(oForm, "btn_ShowDeleted"),
      btn_StatusAktuelleVersion       := FindObject(oForm, "btn_StatusAktuelleVersion"),
      btn_StatusInBearbeitung         := FindObject(oForm, "btn_StatusInBearbeitung"),
      btn_StatusVeraltet              := FindObject(oForm, "btn_StatusVeraltet"),
      btn_StatusZurUeberpruefung      := FindObject(oForm, "btn_StatusZurUeberpruefung"),
      cmb_DocumentAccessCategory      := FindObject(oForm, "cmb_DocumentAccessCategory"),
      cmb_DocumentApprovalState       := FindObject(oForm, "cmb_DocumentApprovalState"),
      cmb_DocumentCategory            := FindObject(oForm, "cmb_DocumentCategory"),
      cmb_DocumentConfidentiality     := FindObject(oForm, "cmb_DocumentConfidentiality"),
      cmb_DocumentResposibility       := FindObject(oForm, "cmb_DocumentResposibility"),
      cmb_DocumentState               := FindObject(oForm, "cmb_DocumentState"),
      cmb_DocumentType                := FindObject(oForm, "cmb_DocumentType"),
      cmb_DocumentUsage               := FindObject(oForm, "cmb_DocumentUsage"),
      ds_Documents_Grid               := FindObject(oForm, "ds_Documents_Grid"),
      ds_Documents_Mask               := FindObject(oForm, "ds_Documents_Mask"),
      ds_MainTable                    := FindObject(oForm, "ds_MainTable"),
      edt_DocumentName                := FindObject(oForm, "edt_DocumentName"),
      edt_DocumentNo                  := FindObject(oForm, "edt_DocumentNo"),
      edt_DocumentVersDesc            := FindObject(oForm, "edt_DocumentVersDesc"),
      edt_DocumentVersNo              := FindObject(oForm, "edt_DocumentVersNo"),
      edt_FileChangeDate              := FindObject(oForm, "edt_FileChangeDate"),
      edt_FileOrHyperLink             := FindObject(oForm, "edt_FileOrHyperLink"),
      edt_FileSize                    := FindObject(oForm, "edt_FileSize"),
      edt_FileType                    := FindObject(oForm, "edt_FileType"),
      edt_searchText                  := FindObject(oForm, "edt_searchText"),
      grd_main                        := FindObject(oForm, "grd_main"),
      lbl_DocumentAccessCategory      := FindObject(oForm, "lbl_DocumentAccessCategory"),
      lbl_DocumentApprovalState       := FindObject(oForm, "lbl_DocumentApprovalState"),
      lbl_DocumentCategory            := FindObject(oForm, "lbl_DocumentCategory"),
      lbl_DocumentConfidentiality     := FindObject(oForm, "lbl_DocumentConfidentiality"),
      lbl_DocumentLinkData            := FindObject(oForm, "lbl_DocumentLinkData"),
      lbl_DocumentLinkDataInfo        := FindObject(oForm, "lbl_DocumentLinkDataInfo"),
      lbl_DocumentName                := FindObject(oForm, "lbl_DocumentName"),
      lbl_DocumentNo                  := FindObject(oForm, "lbl_DocumentNo"),
      lbl_DocumentResponsibility      := FindObject(oForm, "lbl_DocumentResponsibility"),
      lbl_DocumentState               := FindObject(oForm, "lbl_DocumentState"),
      lbl_DocumentType                := FindObject(oForm, "lbl_DocumentType"),
      lbl_DocumentUsage               := FindObject(oForm, "lbl_DocumentUsage"),
      lbl_DocumentVersDesc            := FindObject(oForm, "lbl_DocumentVersDesc"),
      lbl_DocumentVersNo              := FindObject(oForm, "lbl_DocumentVersNo"),
      lbl_File                        := FindObject(oForm, "lbl_File"),
      lbl_FileChangeDate              := FindObject(oForm, "lbl_FileChangeDate"),
      lbl_FileSize                    := FindObject(oForm, "lbl_FileSize"),
      lbl_FileType                    := FindObject(oForm, "lbl_FileType"),
      lbl_geloescht                   := FindObject(oForm, "lbl_geloescht"),
      lbl_Memo                        := FindObject(oForm, "lbl_Memo"),
      MainMenu1                       := FindObject(oForm, "MainMenu1"),
      pnl_DatumUser                   := FindObject(oForm, "pnl_DatumUser"),
      pnl_File                        := FindObject(oForm, "pnl_File"),
      pnl_FileButtons                 := FindObject(oForm, "pnl_FileButtons"),
      pnl_FileCaption                 := FindObject(oForm, "pnl_FileCaption"),
      pnl_FileLinkOrHyperLink         := FindObject(oForm, "pnl_FileLinkOrHyperLink"),
      pnl_FileLinkOrHyperLinkCaption  := FindObject(oForm, "pnl_FileLinkOrHyperLinkCaption"),
      pnl_Filter                      := FindObject(oForm, "pnl_Filter"),
      pnl_geloeschteanzeigen          := FindObject(oForm, "pnl_geloeschteanzeigen"),
      pnl_Grid                        := FindObject(oForm, "pnl_Grid"),
      pnl_leftTree                    := FindObject(oForm, "pnl_leftTree"),
      pnl_LinkButtons                 := FindObject(oForm, "pnl_LinkButtons"),
      pnl_Main                        := FindObject(oForm, "pnl_Main"),
      pnl_Mask                        := FindObject(oForm, "pnl_Mask"),
      pnl_MaskBottomArea              := FindObject(oForm, "pnl_MaskBottomArea"),
      pnl_MaskTopArea                 := FindObject(oForm, "pnl_MaskTopArea"),
      pnl_MemoArea                    := FindObject(oForm, "pnl_MemoArea"),
      pnl_MiddleGrid                  := FindObject(oForm, "pnl_MiddleGrid"),
      pnl_StatusFilter                := FindObject(oForm, "pnl_StatusFilter"),
      pnl_StatusToolBarParent         := FindObject(oForm, "pnl_StatusToolBarParent"),
      pnl_Top                         := FindObject(oForm, "pnl_Top"),
      richedit_DocumentMemo           := FindObject(oForm, "richedit_DocumentMemo"),
      splitter_Mask                   := FindObject(oForm, "splitter_Mask"),
      sub_StatusAendern               := FindObject(oForm, "sub_StatusAendern"),
      SubLoeschen                     := FindObject(oForm, "SubLoeschen"),
      tb_Cancel                       := FindObject(oForm, "tb_Cancel"),
      tb_NewDocument                  := FindObject(oForm, "tb_NewDocument"),
      tb_NewFileLink                  := FindObject(oForm, "tb_NewFileLink"),
      tb_NewFileScan                  := FindObject(oForm, "tb_NewFileScan"),
      tb_NewHyperlink                 := FindObject(oForm, "tb_NewHyperlink"),
      tb_NewVersion                   := FindObject(oForm, "tb_NewVersion"),
      tb_save                         := FindObject(oForm, "tb_save"),
      tb_Zugriffsberechtigung         := FindObject(oForm, "tb_Zugriffsberechtigung"),
      // @VZE@ der vorangehende Teil wird automatisch gepflegt

      oSelectBox              := CreateObject('TSelectBoxEx', '', pnl_StatusFilter, pnl_StatusFilter),
      oSelectBox.Align        := alClient,
      oSelectBox.Height       := 21,
      oSelectBox.DefaultColor := clInfoBk,

      AssignEvent(oSelectBox, 'OnChange', 'SelectBoxChange'),

      oSelectBox.CbAddItem('veraltet'),
      oSelectBox.CbAddItem('aktuell'),
      oSelectBox.CbAddItem('künftig'),
      oSelectBox.CbCheckItem(1),
      oSelectBox.CbCheckItem(2),

   onerror
      DestroyObject(oForm),
      SetError('Error loading gui' + crlf + GetErrorText()),
   stopseq,                                                                     prs('LoadGUI', 'ENDE'),
end,

//******************************************************************************
// ShowGUI zeigt das GUI an, das vorher mit LoadGUI geladen werden muss.
// @Result: null
//******************************************************************************
function ShowGUI()                                                              prs('ShowGUI', 'START'),
   if empty(m_oOwnerForm) then
      ShowModal(oForm),
   else
      Show(oForm),
   endif,                                                                       prs('ShowGUI', 'ENDE'),
end,

//******************************************************************************
// Erstellt das Individualmenü
// @Result: null
//******************************************************************************
function CreateIndiMenu()                                                       prs('CreateIndiMenu', 'START'),
   // Indi-Menu initialisieren und anzeigen
   if gl_DMSU_DockingIndiMenuId > 0 then
      m_oIndiMenu               := CreateObject("TBeCustomMenuPanel", "CustomMenuPanel"+Str(gl_DMSU_DockingIndiMenuId), oForm, oForm),
      m_oIndiMenu.ID            := gl_DMSU_DockingIndiMenuId,
      m_oIndiMenu.InsertInMenu  := false,
      m_oIndiMenu.InsertInBeBar := true,
      m_oIndiMenu.Showmenu,
   endif,                                                                       prs('CreateIndiMenu', 'ENDE'),
end,

//##############################################################################
//##############################################################################
// Hauptprogramm
//##############################################################################
//##############################################################################

startseq
   // Für den Tests in der Entwicklungsumgebung ohne übergebener Master-Tabelle
   if EditorMode() and empty(m_oMasterTable) then
      m_oMasterTable           := DBOpen(waDab010),
      m_oMasterTable.IndexName := 'DAB011',
      DBSeek({'0096-0316-133-00'}, m_oMasterTable),                             // 0096-0316-133-00 |
//      m_oMasterTable           := DBOpen(waDAB730),
//      m_oMasterTable.IndexName := 'DAB731',
//      DBSeek({'TS2320'}, m_oMasterTable),
   endif,

   DMSU_EnsureLocalDocumentsTempFolder(DMSU_CalcUserTempPath(c_usr)),

   InitForm(),
   LoadGUI(),
   CreateIndiMenu(),
   SetDefaults(),
   OpenDataBaseAndLinkToGUI(),
   LoadSettings(),
   TryToSynchronizeDocumentTable(),
   ActionsEnabled(),
   ShowGUI(),
onerror
   GU_ShowStdErrorMessage('Fehler im Programm ' + ProgName(), GetErrorObj()),
stopseq,

// Programm gibt die Formular-Instanz zurück => wichtig z.B. bei Aufruf per 'Call()'
oForm
