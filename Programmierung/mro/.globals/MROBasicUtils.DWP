|
   // Soll das Dokumente-Docking automatisch in der Ressourcen-Verwaltung und
   // bei den Ereignissen angedockt werden?
   gl_MRO_bUseDMS:_L:=false,

   // In der Oberfläche "Aktionen durchführen & dokumentieren" den User-Filter aktivieren -> deaktiviert
   // Man sieht nur noch Aktionen, für die man als "Verantwortlicher" oder
   // "stellvertretender Verantwortlicher" zuständig ist
   gl_MRO_bShowUserFilter:_L:=true,

   // Diese Option legt für die Oberfläche "Aktionen durchführen & dokumentieren" fest, ob man die Abteilung
   // zuerst wählen muss, bevor der Filter für Maschinen und Verantwortliche aktiv wird (=false)
   // Ist der Wert "true", kann man jederzeit alle der Filter verwenden.
   gl_MRO_m_bFilterImmerAktiv:_L:=true,

   // Filter für die individuelle Online-Hilfe-Memos
   gl_MRO_OnlineHilfeFilter:_C:='MEMO_ID = -1',

   // Menü-ID eines Individual-Menüs, welches im Ressourcen-Stamm eingebunden wird
   gl_MRO_IndiMenueRessourcenStamm:_N:=-1

|


//******************************************************************************
// Berechnet die Termintreue
// @Result: numeric - Wert der Termintreue in Prozent (also 100% = 1)
//******************************************************************************
function _MRO_TermintreueBerechnen(cIntervallTyp, nIntervall, nBS_Durchgef, nBS_letzteTat, dLetzteTat, dDurchgef)
   Result := 0,
   if cIntervallTyp == 'BST' then
      Result := (nBS_Durchgef - nBS_letzteTat) / nIntervall,
   else
      Result := Day_Diff(dLetzteTat, dDurchgef) / nIntervall,
   endif,
end,


//******************************************************************************
// Produktions-Auftragas-Status ermitteln
// @Result: -1 - ermittlung fehlgeschlagen
//           0 - unbekannt
//           1 - angelegt
//           2 - kommissioniert
//           3 - abgeschlossen
//******************************************************************************
function _MRO_PuefeAufProdStat(cB_POS_LFD)
| oDAB035, oDAB240 |
   Result := -1,
   if not Empty(cB_POS_LFD) then
      oDAB035 := BeOpen(waDab035, 'DAB03B'),
      oDAB240 := BeOpen(waDab240, 'DAB241'),
      startseq
         if not oDAB035.CbFindKey({left(cB_POS_LFD, 6)}) then
            if oDAB240.CbFindKey({alltrim(cB_POS_LFD)}) then
               Result := 3,
            else
               Result := 0,
            endif,
         else
            if oDAB035:teile_v = 'K' then
               Result := 2,
            else
               Result := 1,
            endif,
         endif,
      always
         BeClose(oDAB035),
         BeClose(oDAB240),
      stopseq,
   endif,
end,

//******************************************************************************
// MY: 2017-07-24
// Ermittelt den Status des Vergleichstermins
// @Result = numeric;
//           -1 = "nicht bestimmbar" ;
//           0 = "unter Kulanz";
//           1 = "im Kulanzzeitfestner";
//           2 = "im Warnzeitfestner";
//******************************************************************************
function _MRO_BerechneTerminStatus(dZielGepant, dVergleich, nInterval, nKulanz, nWarnung)
| nAbweichung |
   Result := -1,
   nAbweichung := (Day_Diff(dZielGepant, dVergleich) ) * 100 / nInterval,
   // Überprüfen ob es im Rahmen der Kulanz/Warung druchgeführt
   // wurde falls der Warnzeitraum überschritten wurde kann
   // Abgebrochen werden
   if nAbweichung <= nKulanz then
      Result := 0,
   else
      if nAbweichung > nKulanz then
         Result := 1,
      endif,
      if nAbweichung > nWarnung then
         Result := 2,
      endif,
   endif,
//   prs( 'MRO_BerechneTerminStatus', 'nAbweichung: ' + str(nAbweichung)
//                                     + ' ; dZielGepant: ' + DToS(dZielGepant)
//                                     + ' ; dVergleich: ' + DToS(dVergleich)
//                                     + ' ; nInterval: ' + str(nInterval)
//                                     + ' ; nKulanz: ' + str(nKulanz)
//                                     + ' ; nWarnung: ' + str(nWarnung)
//                                     + ' ; Ergebnis: ' + str(Result) ),
end,


//******************************************************************************
// MY: 2017-07-24
// Funktion überprüft ob zu der übergebenen Maschinen-ID und optional Ereignis-ID
// nicht abgeschlossene Aktionen existieren, die über den Warn oder Kulanzzeit-
// raum sind. Beide übergebenen Tabellen müssen mit dem Index 'Auswertung' geöffnet
// sein.
// @Result = numeric;
//           -1 = "nichts gefunden" ;
//           0 = "keine Überschreitung";
//           1 = "mindestens ein Wert im Kulanzzeitfestner";
//           2 = "mindestens ein Wert im Warnzeitfestner";
//******************************************************************************
function _MRO_MS_TerminAuswertung(oMROTAT, oMROERG, oMRORES, nID_MASCH, nID_ERG)
| nTerminStatus, nBetriebsStJeTag, oBookTAT, oBookERG, oBookRES, cNameOfEvent |

   cNameOfEvent := 'mro\.customizing\TerminAuswertung',

   if LookUp(waDabPRG, 'BEZ', {{cNameOfEvent}}, 'not EoF()', false, lm_lookup) then
      Result := call(cNameOfEvent, oMROTAT, oMROERG, oMRORES, nID_MASCH, nID_ERG),
   else

      Result := -1,
      oBookRES :=  oMRORES.CbGetBookmarkEx(),
      oBookERG :=  oMROERG.CbGetBookmarkEx(),
      oBookTAT :=  oMROTAT.CbGetBookmarkEx(),
      startseq
         oMRORES.CbFiltered := false,
         oMROERG.CbFiltered := false,
         oMROTAT.CbFiltered := false,

         oMROERG.CbSetRangeEx({nID_MASCH, nID_ERG}),
         oMROERG.CbFirst(),
      //   prs( 'MRO_MS_TerminAuswertung - Start', 'ID_MASCH: ' + str(nID_MASCH) + '; ID_ERG: ' + str(nID_ERG)),
         // alle Ereignisse werden betrachtet, sonfern aktive Aktionen vorhanden sind
         // wird das Solldatum der Aktionen verwendet. Sind keine Aktivitäten
         // vorhanden, wird das Datum der letzten druchführung am Ereignis herangezogen
         while not oMROERG.CbEoF and Result < 2 do
            // Betriebsstunden je Tag setzen, falls das Ereignis den Intervaltyp Tage
            // erhält die Variabele den "Neutralen" Wert "1"
            if alltrim(upper(oMROERG:INTERV_TYP)) == 'TAG' then
               nBetriebsStJeTag := 1,
            else
               oMRORES.CbFindKey({nID_MASCH}),
               case alltrim(upper(oMRORES:DBS_JE))
                  of 'TAG' ::  nBetriebsStJeTag := oMRORES:DBS,
                  of 'WOC' ::  nBetriebsStJeTag := oMRORES:DBS / 7,
                  of 'MON' ::  nBetriebsStJeTag := oMRORES:DBS / 30,
                  otherwise
               endcase,
            endif,

            oMROTAT.CbSetRangeEx({nID_MASCH, oMROERG:ID}),
            oMROTAT.CbFirst(),
            // wenn Aktionen vorhanden sind werden diese ausgelesen, sonst stammen
            // die Informationen aus er Ereignistabelle
            if oMROTAT.CbDataAvailable then
               while not oMROTAT.CbEoF do
                  // als Datum der LEtzten durchführung darf nicht das Datum aus
                  // dem Ereignis verwendet werden, da bei mehreren in die Zukunft
                  // geplanten Ereignisse sonst die Anzeige falsch währe

                  // Wurde zu der tätigkeit schon ein Produktionsauftrag angelegt
                  // und ist bereits kommissioniert, so wird die Vorlaufzeit nicht
                  // mehr berücksichtigt
                  if !Empty(oMROTAT:B_POS_LFD) and MRO_PuefeAufProdStat(oMROTAT:B_POS_LFD) > 1 then
                     Case MRO_BerechneTerminStatus(oMROTAT:ZIELDATUM, date(), (oMROTAT:INTERV / nBetriebsStJeTag), oMROTAT:KULANZ, oMROTAT:WARNUNG)
                        of 0 :: Result := iif(Result = -1, 0, Result),
                        of 1 :: Result := 1,
                        of 2 :: Result := 2,
                        otherwise
                     endcase,
                  else
                     Case MRO_BerechneTerminStatus(oMROTAT:ZIELDATUM - oMROTAT:VORLAUF, date(), (oMROTAT:INTERV / nBetriebsStJeTag), oMROTAT:KULANZ, oMROTAT:WARNUNG)
                        of 0 :: Result := iif(Result = -1, 0, Result),
                        of 1 :: Result := 1,
                        of 2 :: Result := 2,
                        otherwise
                     endcase,
                  endif,

   //               prs( 'MRO_MS_TerminAuswertung - Aktionen', 'ERG: ' + str(oMROERG:ID) + '; AKT: ' + str(oMROTAT:ID) + '; nBetriebsStJeTag: ' + str(nBetriebsStJeTag) + '; Ergebnis: ' + str(Result)),
                  oMROTAT.CbNext(),
               end,
            else
               // wenn das geplante Inaktivierungsdatum in der Vergangenheit liegt
               // wird der Vorlauf nicht berücksichtigt und anstelle des aktuellen
               // das Datum der geplanten Inaktivierung verwendet.
               if !Empty(oMROERG:DAT_INAKTI) and oMROERG:DAT_INAKTI < date() then
                  Case MRO_BerechneTerminStatus(oMROERG:DAT_LZTAKT + (oMROERG:INTERV / nBetriebsStJeTag), oMROERG:DAT_INAKTI, (oMROERG:INTERV / nBetriebsStJeTag), oMROERG:KULANZ, oMROERG:WARNUNG)
                     of 0 :: Result := if(Result = -1, 0, Result),
                     of 1 :: Result := 1,
                     of 2 :: Result := 2,
                     otherwise
                  endcase,
               else
                  Case MRO_BerechneTerminStatus(oMROERG:DAT_LZTAKT + (oMROERG:INTERV / nBetriebsStJeTag) - oMROERG:VORLAUF, date(), (oMROERG:INTERV / nBetriebsStJeTag), oMROERG:KULANZ, oMROERG:WARNUNG)
                     of 0 ::Result := if(Result = -1, 0, Result),
                     of 1 :: Result := 1,
                     of 2 :: Result := 2,
                     otherwise
                  endcase,
               endif,
   //            prs( 'MRO_MS_TerminAuswertung - Ereigniss', 'ERG: ' + str(oMROERG:ID) + '; nBetriebsStJeTag: ' + str(nBetriebsStJeTag) + ';  Ergebnis: ' + str(Result)),
            endif,
            oMROERG.CbNext(),
         end,
      always
         oMRORES.CbGoToBookmarkEx(oBookRES, True),
         oMROERG.CbGoToBookmarkEx(oBookERG, True),
         oMROTAT.CbGoToBookmarkEx(oBookTAT, True),
      stopseq,
   endif,
end,


//******************************************************************************
// Diese Funktion Berechnet den Terminstatus für das übergegebene Ereignis (wenn
// wenn beide ID übergeben werden. Für alle ergeignisse einer Machine, falls nur
// eine MaschinenID übergeben wird. Oder für alle Maschinen und Ereignisse (wenn
// kein Parameter übergeben wird).
// @Result: null
//******************************************************************************
function _MRO_MS_WartungszustandBerechnen(nID_MASCH, nID_ERG)
| oDM, oMROTAT, oMROERG, oMRORES, oMRORES_Edit, oMROERG_Edit, nWartungszustand |

   // Wird nur eine Ereignis ID übergehen aber keine Maschinen ID, so muss
   // die die Maschinen ID ermittelt werden
   If !Empty(nID_ERG) and Empty(nID_MASCH) then
      SetError("Die Funktion 'MRO_MS_WartungszustandBerechnen' benötigt eine MaschinenID wenn eine EreignisID übergeben wird."),
      Exit,
   endif,
   Result := '',

   oDM                       := CreateObject('TbeDbGet', 'CALCWARTZU'),
   startseq
      oMROTAT                := DBGetTable(oDM, waMROTAT, 'MROTAT'),
      oMROTAT.indexname      := 'AUSWERTUNG',                                        //Index: ID_MASCH; ID_ERG
      oMROERG                := DBGetTable(oDM, waMROERG, 'MROERG'),
      oMROERG.indexname      := 'AUSWERTUNG',                                        //Index: ID_MASCH; ID
      oMROERG_Edit           := DBGetTable(oDM, waMROERG, 'MROERG_Edit'),
      oMROERG_Edit.indexname := 'AUSWERTUNG',                                        //Index: ID_MASCH; ID
      oMRORES                 := DBGetTable(oDM, waMRORES, 'MRORES'),
      oMRORES.indexname       := 'ID',                                                //Index: ID
      oMRORES_Edit            := DBGetTable(oDM, waMRORES, 'MRORES_Edit'),
      oMRORES_Edit.indexname  := 'ID',                                                //Index: ID

      // die eine oder alle Maschinen betrachten
      oMRORES_Edit.CbSetRangeEx({nID_MASCH}),
      oMRORES_Edit.CbFirst(),
      while not oMRORES_Edit.CbEoF do
         nWartungszustand := MRO_MS_TerminAuswertung(oMROTAT, oMROERG, oMRORES, oMRORES_Edit:ID, nil),
         // Falls der Datensatz nicht Editiert werden kann soll er am Ende ausgegeben werden.
         if oMRORES_Edit.CbEdit() then
            oMRORES_Edit:WART_ZUSTA := nWartungszustand,
            oMRORES_Edit.CbPost(),
            prs( 'MRO_MS_WartungszustandBerechnen - Maschine', '#' + str(nWartungszustand) + '# - MS: ' + alltrim(oMRORES_Edit:BEZ1) + ' (' + str(oMRORES_Edit:ID) + ')' ),
         else
            Result += CRLF + '   - ' + Alltrim(oMRORES_Edit:BEZ1),
         endif,

         // das eine oder alle Ereignisse der Maschine betrachten
         oMROERG_Edit.CbSetRangeEx({oMRORES_Edit:ID, nID_ERG}),
         oMROERG_Edit.CbFirst(),
         while not oMROERG_Edit.CbEof do
            nWartungszustand := MRO_MS_TerminAuswertung(oMROTAT, oMROERG, oMRORES, oMRORES_Edit:ID, oMROERG_Edit:ID),
            prs( 'MRO_MS_WartungszustandBerechnen - Ereignis', '#' + str(nWartungszustand) + '# - MS: ' + alltrim(oMRORES_Edit:BEZ1) + ' (' + str(oMRORES_Edit:ID) + '); ERG: ' +  alltrim(oMROERG_Edit:BEZ1) + ' (' + str(oMROERG_Edit:ID) + ')' ),
            // Falls der Datensatz nicht Editiert werden kann soll er am Ende ausgegeben werden.
            if oMROERG_Edit.CbEdit() then
               oMROERG_Edit:WART_ZUSTA := nWartungszustand,
               oMROERG_Edit.CbPost(),
            else
               Result += CRLF + '   - ' + Alltrim(oMRORES_Edit:BEZ1) + ' - ' + alltrim(oMROERG_Edit:BEZ1),
            endif,
            oMROERG_Edit.CbNext(),
         end,
         oMRORES_Edit.CbNext(),
      end,
   always
      DestroyObject(oDM),
   stopseq,
end,

//******************************************************************************
// Volltext-Suchtext für die RessourcenVerwaltung (MRORES berechnen
//   (für Update-Codeblock im Feld 'SUCHE')
// @Result: string
//******************************************************************************
function _FTS_CalcSearchTextForMRORES(oMRORES)

   // Einen Wert dem FTS-Such-String hinzufügen (Übergabe per Referenz!)
   function AddValueToSearchText(cSearchText:R, uValue)
      uValue := AllTrim(ToString(uValue)),
      if not empty(uValue) then
         cSearchText := ConcatTrenner(cSearchText, uValue, crlf),
      endif,
   end,

   Result := '',

   // Alle ggf. interessanten Infos aufnehmen:
   AddValueToSearchText(Result, oMRORES:BEZ1),
   AddValueToSearchText(Result, oMRORES:BEZ_TYP),
   AddValueToSearchText(Result, oMRORES:KOMMISS),
   AddValueToSearchText(Result, oMRORES:INVENTARNR),
   AddValueToSearchText(Result, oMRORES:BEZ_FABT),
   AddValueToSearchText(Result, oMRORES:ORT_MASCH),
   AddValueToSearchText(Result, RtfToText(oMRORES:MEMO)),

   Result := PrepareTextForFTS(waMRORES, 'SUCHE', Result, true),
end,

//******************************************************************************
// Sortiert ein eindimensionales Array.
// Der zweite Parameter entscheidet ob die Inhalte nur numerisch sind. Falls ja
// wird der Inhalt korrekt Nummerisch sortiert.
// Grundlegen kann das Array alle Typen außer Objekten und "undefiend" enthalten
// @Result: Sortiertes Array, '{}' wenn ein Fehler auftritt
//******************************************************************************
function _MRO_MS_ArraySortieren(aArray, bArrayNurZahlen:B:=false)
| oMem, i |
   Result := {},
   startseq
      oMem := CreateObject("TBeMemTable", "ARRSORT"),
      if bArrayNurZahlen then
         oMem.CbAddField('WERT', FtFloat, 0),
      else
         oMem.CbAddField('WERT', FtMemo, 0),
      endif,
      oMem.CbAddField('TYP',  FtString, 1),
      oMem.Active  := true,
      oMem.CbAddIndex('SORT', 'WERT', ixPrimary),

      for i:=1 to alen(aArray) do
         oMem.CbAppend(),
         oMem:TYP  := ValType(aArray[i]),
         if bArrayNurZahlen then
            if oMem:TYP <> 'N' then
               seterror('Die Funktion "ArraySortieren(aArray)" kann im Modus "NurZahlen" keine anderen Datentypen verarbeiten. ', 1),
            endif,
            oMem:WERT := aArray[i],
         else
            case oMem:TYP
               of 'A' :: oMem:WERT := ArrToStr(aArray[i]),
               of 'D' :: oMem:WERT := FormatDateTime('YYYY.MM.DD HH:MM:NN:ZZZ', aArray[i]),
               of 'L' :: oMem:WERT := if(aArray[i], 'wahr', 'falsch'),
               of 'O' :: SetError('Die Funktion "ArraySortieren(aArray)" unterstützt keine Objekte in Arrays', 1),
               of 'U' :: SetError('Die Funktion "ArraySortieren(aArray)" unterstützt keine Kompenenten vom Typ "Undefined" in Arrays', 1),
               otherwise oMem:WERT := aArray[i],
            endcase,
         endif,
         oMem.CbPost(),
      end,

      oMem.CbFirst(),
      while not oMem.CbEoF do
         case oMem:TYP
            of 'C' :: Aadd(Result, oMem:WERT),
            of 'A' :: Aadd(Result, StrToArr(oMem:WERT)),
            of 'D' :: Aadd(Result, EncodeDate( val(StrToken(StrToken(oMem:Wert, ' ', 1), '.', 1)),
                                               val(StrToken(StrToken(oMem:Wert, ' ', 1), '.', 2)),
                                               val(StrToken(StrToken(oMem:Wert, ' ', 1), '.', 3))
                                              ) +
                                   EncodeTime( val(StrToken(StrToken(oMem:Wert, ' ', 2), ':', 1)),
                                               val(StrToken(StrToken(oMem:Wert, ' ', 2), ':', 2)),
                                               val(StrToken(StrToken(oMem:Wert, ' ', 2), ':', 3)),
                                               val(StrToken(StrToken(oMem:Wert, ' ', 2), ':', 4))
                                             )),
            of 'N' :: Aadd(Result, tofloat(oMem:WERT)),
            of 'L' :: Aadd(Result, oMem:WERT = 'wahr') ,
            otherwise Aadd(Result, oMem:WERT),
         endcase,
         oMem.CbNext(),
      end,

   always
      DestroyObject(oMem),
   stopseq,
end,

