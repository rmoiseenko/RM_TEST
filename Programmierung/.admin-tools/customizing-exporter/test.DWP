//##############################################################################
//##############################################################################
//
//   Programm zur Erstellung eines Export-Packages für alle Customizings in be
//
//     /CM, 08.11.20:
//     - Begonnen mit der Definition eines Export-Formats für
//          Tabellen-Definitionen
//             Grundsätzliches Vorgehen beim Export der Tabellen-Strukturen:
//               Nur exportieren, was vom Default abweicht. Das Ziel ist, dass eine Tabellen-Definition
//               auch "Menschen-Schreibbar" ist
//          TODO: Siehe Todos im Code
//     - Geplant:
//       Export-/ Austausch-Format definieren für MM-Tabellen (mit "Schlüssel" für Unabhängigkeit von der ID)
//       Export-/ Austausch-Format definieren für Indi-Menüs  (mit "Schlüssel" für Unabhängigkeit von der ID)
//
//##############################################################################
//##############################################################################

|
   gl_temp_ftShort:_N:= 2,
   gl_temp_ftBytes:_N:= 12,
   gl_temp_ftAutoInc:_N:= 14,
   gl_temp_ftCiCharacter:_N:= 100
|

//******************************************************************************
// Funktion ermittelt zu einem Tabellen-Namen die Workarea
// @Result: Integer, Workarea,
//          -1 im Falle, dass die Tabelle nicht gefunden wurde
//******************************************************************************
function FindWorkareaForTableName(cTableName:C)
| i, oTableInfo |
   Result := -1,
   for i := 999 downto 1 do
      oTableInfo := GetTableInfo(i), // TBeTableInfo
      if not Empty(oTableInfo) then
         // WriteLn(i, oTableInfo.TableDef.TableName),
         if Lower(oTableInfo.TableDef.TableName) == Lower(cTableName) then // TBeTableDef
            Result := i,
            break,
         endif,
      endif,
   next,
end,

function Add_String_ElemIfNotEmpty(oParentElement, cElementName, cValue)
   if not empty(cValue) then
      oParentElement.AddElement(cElementName, cValue),
   endif,
end,

function Add_Bool_ElemIfNotDefault(oParentElement, cElementName, bDefaultValue, bCurrentValue)
   if bDefaultValue <> bCurrentValue then
      oParentElement.AddElement(cElementName, bCurrentValue),
   endif,
end,

//******************************************************************************
// Fügt den Feld-Kommentar als JSON Element hinzu.
//    Einzeilige Kommentare als <string>, Mehrzeilige als <Array of String>
// @Result: keine Rückgabe
//******************************************************************************
function AddColumnComment(oColumnElement:O, oFieldInfo:O)
| oCommentElement, bNumberOfLines, oCommentArray, t, cLine |
   if not empty(oFieldInfo.Comment) then
      bNumberOfLines := TokenCount(oFieldInfo.Comment, crlf),
      if bNumberOfLines = 1 then
         oColumnElement.AddElement('comment', oFieldInfo.Comment),
      else
         oCommentArray := oColumnElement.AddArrayElement('comment'), // TBeasArrayServiceParamItem
         for t := 1 to bNumberOfLines do
            cLine := Token(oFieldInfo.Comment, crlf, t),
            oCommentArray.AddArrayNamedValue('e_' + Str(t), cLine), // Warum auch immer muss man hier einen Element-Namen mitgeben, im json Ergebnis ist dieser nicht drin...
         next,
      endif,
   endif,
end,

//******************************************************************************
// Fügt den Feld-Typ (+ ggf. Länge und Dezimal-Stellen) als JSON Element(e) hinzu.
// @Result: keine Rückgabe
//******************************************************************************
function AddColumnType(oColumnElement:O, oTable:O, oField:O, oFieldInfo:O)
| cFieldName, oFieldDefItem, oItem, i, cType,
  bLengthCanBeDefined, bDecimalsCanBeDefined, cFieldType |

   cFieldName    := oFieldInfo.FieldName,

   // Über die FieldDefs der TBeRightsTable kommt man an die Länge und Dezimalstellen
   oFieldDefItem := nil,
   for i := 1 to CollCount(oTable.FieldDefs) do
      oItem := CollItem(oTable.FieldDefs, i),
      if oItem.Name == cFieldName then
         oFieldDefItem := oItem,
         break,
      endif,
   next,
   SetErrorIf(empty(oFieldDefItem), 'fielddef item not found for field "' + cFieldName + '" in table "' + oTable.TableName + '"'),

   bLengthCanBeDefined   := false,
   bDecimalsCanBeDefined := false, // Unter ADT gibt es aktuell keine für be freigegebenen Feldtypen mit definierbaren Dezimalstellen

   cFieldType := DbFieldType(DbField(cFieldName, oTable)), //WriteLn(cFieldType),

   case cFieldType
       of 'CHARACTER'            :: cType := 'Character',      bLengthCanBeDefined := true,
       of 'DOUBLE'               :: cType := 'Double',
       of 'INTEGER'              :: cType := 'Integer',
       of 'SHORTINT'             :: cType := 'ShortInt',
       of 'DATE'                 :: cType := 'Date',
       of 'TIME'                 :: cType := 'Time',
       of 'TIMESTAMP'            :: cType := 'TimeStamp',
       of 'LOGICAL'              :: cType := 'Logical',
       of 'MEMO'                 :: cType := 'Memo',
       of 'BINARY'               :: cType := 'Binary',
       of 'AUTOINC'              :: cType := 'AutoIncrement',
       of 'RAW'                  :: cType := 'Raw',            bLengthCanBeDefined := true,
       of 'CICHARACTER'          :: cType := 'CICharacter',    bLengthCanBeDefined := true,
    otherwise
       SetError('unknown datatype "' + cFieldType + '" of field "' + cFieldName + '", table "' + oTable.TableName + '"'),
    endcase,

   oColumnElement.AddElement('type',     cType),
   if bLengthCanBeDefined then
      oColumnElement.AddElement('length',   oFieldDefItem.Size),
   endif,
   if bDecimalsCanBeDefined then
      oColumnElement.AddElement('decimals', oFieldDefItem.Precision),
   endif,
end,


//******************************************************************************
// Fügt die Feld-Klassifizierung als JSON Element(e) hinzu.
// @Result: keine Rückgabe
//******************************************************************************
function AddColumnClassification(oColumnElement:O, oTable:O, oFieldInfo:O)
| cClass |

   if oFieldInfo.FieldSpec <> 0 then
      case oFieldInfo.FieldSpec
         of 0 :: cClass := 'none',
         of 1 :: cClass := 'ArtikelNr',
         of 2 :: cClass := 'KundenNr',
         of 3 :: cClass := 'LieferantenNr',
         of 4 :: cClass := 'VertreterNr',
         of 5 :: cClass := 'SachkontoNr',
         of 6 :: cClass := 'KostenstellenNr',
         of 7 :: cClass := 'SachkontoNr-KostenstellenNr-PersonenkontoNr',    // z.B. Verwendet in DF010:KONTO
         of 8 :: cClass := 'KommissNr'

         otherwise
            SetError('unknown field spec "' + Str(oFieldInfo.FieldSpec) + '" in field "' + oFieldInfo.FieldName + '", table "' + oTable.TableName + '"'),
      endcase,

      oColumnElement.AddElement('class', cClass),
   endif,
end,

//******************************************************************************
// Fügt Infos über GUI Optionen hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AddColumnGuiOptions(oColumn:O, oTable:O, oFieldInfo:O)
| oElem |

   //***************************************************************************
   // Feld-Ausrichtung (alignment) hinzufügen
   //***************************************************************************
   function AddColumnAlignment(oJsonElem:O, oTable:O, oFieldInfo:O)
   | cAlignment |

      if oFieldInfo.FieldAlign <> 0 then

         case oFieldInfo.FieldAlign
            of 0 :: cAlignment := 'default',
            of 1 :: cAlignment := 'left',
            of 2 :: cAlignment := 'right',
            of 3 :: cAlignment := 'centered',
            otherwise
               SetError('unknown alignment "' + Str(oFieldInfo.FieldAlign) + '" in field "' + oFieldInfo.FieldName + '", table "' + oTable.TableName + '"'),
         endcase,

         oJsonElem.AddElement('alignment', cAlignment),
      endif,
   end,

   oElem := oColumn.AddComplexElement('gui'),

   Add_Bool_ElemIfNotDefault(oElem, 'options-can-be-user-defined',  true,   not oFieldInfo.NotUserDef),      // NOT "nicht benutzerdefinierbar" -> Wert umgedreht, weil er dann leichter verständlich ist
   Add_Bool_ElemIfNotDefault(oElem, 'options-are-user-defined',     false,  oFieldInfo.MaskOptUserDef),      // "Masken-Optionen benutzerdefiniert"

   if oFieldInfo.Mask_Control <> '' then
      oElem.AddElement('mask-control', oFieldInfo.Mask_Control),
   endif,

   if oFieldInfo.AttribID <> 0 then
      oElem.AddElement('attribute-id', oFieldInfo.AttribID),      // TODO: Sofern die hinterlegte MM-Tabelle eine GUID hat, diese nutzen. Warten auf neues Feld DABMTA:<GUID> - bei SI bestellt für die 7.2
   endif,

   AddColumnAlignment(oElem, oTable, oFieldInfo),

   if oFieldInfo.Mask_Picture  <> '' then
      oElem.AddElement('picture-mask', oFieldInfo.Mask_Picture),
   endif,

   Add_Bool_ElemIfNotDefault(oElem, 'available-in-mask-designer', true,  oFieldInfo.MaskAvailable),      // "Feld für Masken-Designer verfügbar"
   Add_Bool_ElemIfNotDefault(oElem, 'must-exist-on-mask',         false, oFieldInfo.MaskMustExist),      // Feld muß auf Maske existieren
   Add_Bool_ElemIfNotDefault(oElem, 'allow-duplicates-on-mask',   false, oFieldInfo.MaskDuplicates),     // Duplikate innerhalb der Maske erlaubt


   // "gui" Element löschen, sofern komplett leer
   if oElem.ElementCount = 0 then
      oColumn.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt Infos über Standort Optionen hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AddColumnLocationOptions(oColumn:O, oTable:O, oFieldInfo:O)
| oElem, cLocationType |

   oElem := oColumn.AddComplexElement('location'),

   // Standort-Typ
   // -> .LocationType ist intern ein enum mit folgenden Ausprägungen: (ltGlobal = 0, ltLocation = 1, ltDepart = 2)
   //  0 = Global, nicht standortbezogen änderbar
   //  1 = Standort-Feld, nicht abteilungsbezogen änderbar
   //  2 = Abteilungs-Feld
   if oFieldInfo.LocationType <> 0 then
      case oFieldInfo.LocationType
         of 0 :: cLocationType := 'global',
         of 1 :: cLocationType := 'per-location',
         of 2 :: cLocationType := 'per-department',
         otherwise
            SetError('unknown LocationType "' + Str(oFieldInfo.LocationType) + '" in field "' + oFieldInfo.FieldName + '", table "' + oTable.TableName + '"'),
      endcase,
      oElem.AddElement('location-type', cLocationType),
   endif,

   // "Feld ist standortfähig"
   Add_Bool_ElemIfNotDefault(oElem, 'can-be-location-specific',       false, oFieldInfo.FieldIsLocationable),

   // "Änderungen beim Speichern NICHT für alle Standorte übernehmen"
   // -> .LocationCopy ist intern ein enum mit folgenden Ausprägungen: (lcEdit = 0, lcDontCopy = 1)
   if oFieldInfo.LocationCopy = 1 then
      oElem.AddElement('do-not-copy-to-other-locations', true),
   endif,

   // "location" Element löschen, sofern komplett leer
   if oElem.ElementCount = 0 then
      oColumn.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt die Feld-Rechte-Codeblöcke hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AppendColumn_Rights(oColumn:O, oFieldInfo:O)
| oElem |

   oElem := oColumn.AddComplexElement('rights'),

   Add_String_ElemIfNotEmpty(oElem, 'read-default', oFieldInfo.DefRight_Read),
   Add_String_ElemIfNotEmpty(oElem, 'read-custom',  oFieldInfo.Right_Read),

   Add_String_ElemIfNotEmpty(oElem, 'edit-default', oFieldInfo.DefRight_Edit),
   Add_String_ElemIfNotEmpty(oElem, 'edit-custom',  oFieldInfo.Right_Edit),

   if oElem.ElementCount = 0 then
      oColumn.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt die Feld-Validierungs-Codeblöcke hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AppendColumn_Validation(oColumn:O, oFieldInfo:O)
| oElem |

   oElem := oColumn.AddComplexElement('validation'),

   Add_String_ElemIfNotEmpty(oElem, 'validation-default',      oFieldInfo.DefRight_Validate),
   Add_String_ElemIfNotEmpty(oElem, 'validation-custom',       oFieldInfo.Right_Validate),

   Add_String_ElemIfNotEmpty(oElem, 'mask-validation-default', oFieldInfo.DefRight_MaskValid),
   Add_String_ElemIfNotEmpty(oElem, 'mask-validation-custom',  oFieldInfo.Right_MaskValid),

   if oElem.ElementCount = 0 then
      oColumn.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt die Feld-Trigger-Codeblöcke hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AppendColumn_Trigger(oColumn:O, oFieldInfo:O)
| oElem |

   oElem := oColumn.AddComplexElement('trigger'),

   Add_String_ElemIfNotEmpty(oElem, 'new-default',        oFieldInfo.DefRight_New),
   Add_String_ElemIfNotEmpty(oElem, 'new-custom',         oFieldInfo.Right_New),

   Add_String_ElemIfNotEmpty(oElem, 'update-default',     oFieldInfo.DefRight_Update),
   Add_String_ElemIfNotEmpty(oElem, 'update-custom',      oFieldInfo.Right_Update),

   if oElem.ElementCount = 0 then
      oColumn.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
//
// @Result: null
//******************************************************************************
function RecognizeDefaultFields(oColumnElement, oTable, oFieldInfo)
| cFieldName, cType, cDescription, nFieldLength, oGui, cMaskControl |


  function DeleteElementWhenValueIsDefault(oParent, cElementName, uDefaultValue)
     if oParent.ElementExists(cElementName) and VarEqual(oParent.ElementValue(cElementName), uDefaultValue) then
        oParent.DeleteElement(cElementName),
     endif,
  end,


   cFieldName   := oColumnElement.ElementValue('name'),
   cType        := oColumnElement.ElementValue('type'),
   cDescription := oColumnElement.ElementValue('description'),

   case cFieldName
     of 'ID' ::

        if cType == 'Integer' and cDescription == 'Datensatz-ID' then
           oColumnElement.AddElement('prototype', 'ID'),
           oColumnElement.DeleteElement('name'),
           oColumnElement.DeleteElement('type'),
           oColumnElement.DeleteElement('description'),
        else
           if cType == 'AutoIncrement' and cDescription == 'Datensatz-ID' then
              oColumnElement.AddElement('prototype', 'ID_AUTOINC'),
              oColumnElement.DeleteElement('name'),
              oColumnElement.DeleteElement('type'),
              oColumnElement.DeleteElement('description'),
           endif,
        endif,

     of 'ERSTELLT' ::

        if cType == 'TimeStamp' and cDescription == 'Erstellt am / um' then
           oColumnElement.AddElement('prototype', 'ERSTELLT'),
           oColumnElement.DeleteElement('name'),
           oColumnElement.DeleteElement('type'),
           oColumnElement.DeleteElement('description'),

           // Weitere Eigenschaften löschen, sofern sie dem Default entsprechen
           if oColumnElement.ElementExists('gui') then
              oGui         := oColumnElement.Element('gui'),
              DeleteElementWhenValueIsDefault(oGui, 'mask-control', 'TbeEditDatePicker'), // Standard unter 6.5 war 'TBeDateTimePicker'
              if oGui.ElementCount = 0 then
                 oColumnElement.DeleteElement(oGui.Name),
              endif,
           endif,
        endif,

     of 'PLATZ' ::

        if cType == 'Character' and cDescription == 'Erstellt durch' then
           nFieldLength := oColumnElement.ElementValue('length'),
           if nFieldLength = 3 then
              oColumnElement.AddElement('prototype', 'PLATZ'),
              oColumnElement.DeleteElement('name'),
              oColumnElement.DeleteElement('type'),
              oColumnElement.DeleteElement('length'),
              oColumnElement.DeleteElement('description'),

              // Weitere Eigenschaften löschen, sofern sie dem Default entsprechen
              if oColumnElement.ElementExists('gui') then
                 oGui := oColumnElement.Element('gui'),
                 DeleteElementWhenValueIsDefault(oGui, 'mask-control', 'TBeCombo'),
                 DeleteElementWhenValueIsDefault(oGui, 'attribute-id', -11),
                 if oGui.ElementCount = 0 then
                    oColumnElement.DeleteElement(oGui.Name),
                 endif,
              endif,

           endif,
        endif,

     of 'GEAENDERT' ::

        if cType == 'TimeStamp' and cDescription == 'Zuletzt geändert am / um' then
           oColumnElement.AddElement('prototype', 'GEAENDERT'),
           oColumnElement.DeleteElement('name'),
           oColumnElement.DeleteElement('type'),
           oColumnElement.DeleteElement('description'),

           // Weitere Eigenschaften löschen, sofern sie dem Default entsprechen
           if oColumnElement.ElementExists('gui') then
              oGui         := oColumnElement.Element('gui'),
              DeleteElementWhenValueIsDefault(oGui, 'mask-control', 'TbeEditDatePicker'), // Standard unter 6.5 war 'TBeDateTimePicker'
              if oGui.ElementCount = 0 then
                 oColumnElement.DeleteElement(oGui.Name),
              endif,
           endif,
        endif,

     of 'GEAEND_USR' ::

        if cType == 'Character' and cDescription == 'Zuletzt geändert durch' then
           nFieldLength := oColumnElement.ElementValue('length'),
           if nFieldLength = 3 then
              oColumnElement.AddElement('prototype', 'GEAEND_USR'),
              oColumnElement.DeleteElement('name'),
              oColumnElement.DeleteElement('type'),
              oColumnElement.DeleteElement('length'),
              oColumnElement.DeleteElement('description'),

              // Weitere Eigenschaften löschen, sofern sie dem Default entsprechen
              if oColumnElement.ElementExists('gui') then
                 oGui := oColumnElement.Element('gui'),
                 DeleteElementWhenValueIsDefault(oGui, 'mask-control', 'TBeCombo'),
                 DeleteElementWhenValueIsDefault(oGui, 'attribute-id', -11),
                 if oGui.ElementCount = 0 then
                    oColumnElement.DeleteElement(oGui.Name),
                 endif,
              endif,
           endif,
        endif,

     of 'SUCHE' ::

        if cType == 'Memo' and cDescription == 'Volltext-Suche' then
           oColumnElement.AddElement('prototype', 'SUCHE'),
           oColumnElement.DeleteElement('name'),
           oColumnElement.DeleteElement('type'),
           oColumnElement.DeleteElement('description'),
        endif,

   endcase,
end,

//******************************************************************************
// Fügt dem übergebenen JSON Element ('columns') einen Eintrag für jedes Feld hinzu
// @Result: keine Rückgabe
//******************************************************************************
function AppendTableColumns(oColumnsArray:O, oTableInfo:O)
| oFieldInfoList, i, oField, oFieldInfo, oColumnElement, oTable |

   oFieldInfoList := oTableInfo.FieldRightList,    // Liefert 'TBeCbTableFieldDefinitionList'

   oTable := BeOpen(oTableInfo.TableWorkArea), // Liefert 'TBeRightsTable'
   startseq
      for i := 1 to oTable.CbFieldCount -1 do
         oField := oTable.CbField(i),     // WriteLn(oField),

         // be-Zusatzinfos zum Feld holen
         oFieldInfo := oFieldInfoList.CbFieldInfo(oField.FieldName), // Liefert 'TBeCbFieldInformation'

         oColumnElement := oColumnsArray.AddComplexElement(''),

         // Wenn keine FieldInformation vorhanden ist, dann wurden keine DABFIL Infos gepflegt - typischerweise, wenn eine Indi-Tabelle einfach nur eingebunden wurde...
         if empty(oFieldInfo) then
            oColumnElement.AddElement('name',        oField.FieldName),
            oColumnElement.AddElement('description', '<no field info available - meta data missing>'),
         else
            oColumnElement.AddElement('name',        oFieldInfo.FieldName),
            oColumnElement.AddElement('description', oFieldInfo.DisplayName),

            AddColumnComment(oColumnElement, oFieldInfo),
            AddColumnType(oColumnElement, oTable, oField, oFieldInfo),

            // Spezifikation
            AddColumnClassification(oColumnElement, oTable, oFieldInfo),

            // GUI Optionen
            AddColumnGuiOptions(oColumnElement, oTable, oFieldInfo),

            // Rechte, Validierung & Trigger
            AppendColumn_Rights(oColumnElement, oFieldInfo),
            AppendColumn_Validation(oColumnElement, oFieldInfo),
            AppendColumn_Trigger(oColumnElement, oFieldInfo),

            // Sonstiges
            Add_Bool_ElemIfNotDefault(oColumnElement, 'copy-value-when-duplicating', false, oFieldInfo.Copyable),       // "Feld bei Stamm-Datensatz-Kopie berücksichtigen"
            Add_Bool_ElemIfNotDefault(oColumnElement, 'editable-by-customizing',     true,  oFieldInfo.Right_IndiGet),  // "Feld darf von Indiv.Programm verändert werden" -> CM/SI 09.11.2020: Diese Eigenschaft ist offenbar ein Relikt aus Zeiten der GetList. Eine durchgängige Wirkung hat die Eigenschaft nicht und durchgängig identisch / sinnvoll gesetzt ist sie auch überhaupt nicht.

            // Standort-Eigenschaften
            AddColumnLocationOptions(oColumnElement, oTable, oFieldInfo),

            // Default-Felder erkennen (Grund-Eigenschaften sind alle entsprechend dem Default gesetzt)
            RecognizeDefaultFields(oColumnElement, oTable, oFieldInfo),

         endif,

      next,
   always
      BeClose(oTable),
   stopseq,

end,

//******************************************************************************
// Fügt die Kopf-Rechte-Codeblöcke hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AppendTable_Rights(oTableEntry:O, oTableInfo:O)
| oElem |

   oElem := oTableEntry.AddComplexElement('rights'),

   Add_String_ElemIfNotEmpty(oElem, 'read',     oTableInfo.Right_Read),
   Add_String_ElemIfNotEmpty(oElem, 'edit',     oTableInfo.Right_Edit),
   Add_String_ElemIfNotEmpty(oElem, 'delete',   oTableInfo.Right_Delete),
   Add_String_ElemIfNotEmpty(oElem, 'insert',   oTableInfo.Right_Insert),

   if oElem.ElementCount = 0 then
      oTableEntry.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt den Kopf-Validierungs-Codeblock hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AppendTable_Validation(oTableEntry:O, oTableInfo:O)
| oElem |

   oElem := oTableEntry.AddComplexElement('validation'),

   Add_String_ElemIfNotEmpty(oElem, 'validation',  oTableInfo.Right_Validate),

   if oElem.ElementCount = 0 then
      oTableEntry.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt die Kopf-Trigger-Codeblöcke hinzu, sofern definiert
// @Result: keine Rückgabe
//******************************************************************************
function AppendTable_Trigger(oTableEntry:O, oTableInfo:O)
| oElem |

   oElem := oTableEntry.AddComplexElement('trigger'),

   Add_String_ElemIfNotEmpty(oElem, 'new',    oTableInfo.Right_UpdNew),
   Add_String_ElemIfNotEmpty(oElem, 'update', oTableInfo.Right_UpdUpd),
   Add_String_ElemIfNotEmpty(oElem, 'delete', oTableInfo.Right_UpdDel),

   if oElem.ElementCount = 0 then
      oTableEntry.DeleteElement(oElem.Name),
   endif,
end,

//******************************************************************************
// Fügt dem übergebenen JSON Element die Tabellen-Infos hinzu
// @Result: keine Rückgabe
//******************************************************************************
function AppendSingleTableToTablesObject(oTableArray:O, cTableName:C)
| nWorkarea, oTableInfo, oTableEntry, oColumnsArray |
   oTableEntry := oTableArray.AddComplexElement(''),

   nWorkarea   := FindWorkareaForTableName(cTableName),
   oTableEntry.AddElement('name',         cTableName),
   oTableEntry.AddElement('workarea',     nWorkarea),

   oTableInfo := GetTableInfo(nWorkarea), // oTableInfo:                TBeTableInfo
                                          // oTableInfo.TableDef:       TBeTableDef
                                          // oTableInfo.FieldRightList: TBeFieldInfoList
                                          // WriteLn(proparray(oTableInfo.TableDef)),
   SetErrorIf(empty(oTableInfo), 'no table info available for workarea ' + Str(nWorkarea)),

   oTableEntry.AddElement('alias',        oTableInfo.TableDef.AliasName),
   oTableEntry.AddElement('description',  oTableInfo.TableLabel),

   // Kopf Rechte, Validierung, Trigger
   AppendTable_Rights(oTableEntry, oTableInfo),
   AppendTable_Validation(oTableEntry, oTableInfo),
   AppendTable_Trigger(oTableEntry, oTableInfo),

   // Felder
   oColumnsArray := oTableEntry.AddArrayElement('columns'),
   AppendTableColumns(oColumnsArray, oTableInfo),

  // TODO: Indices
end,

//******************************************************************************
// Test-Methode
// @Result: JSON String
//******************************************************************************
function BuildDemo_BePackageJson(bAllTables)
| oJSONObj, oCustomizingObjects, oTableArray, i, oTableInfo |
  oJSONObj := CreateObject('TBeasCbServiceOutputParam'),
  startseq
     oJSONObj.InitCbParam(),

     oJSONObj.AddParam('name', 'be-demo-package'),
     oJSONObj.AddParam('description', 'be-demo-package'),
     oJSONObj.AddParam('version', '0.0.1'),
     oJSONObj.AddParam('be_base_folder', 'test\be-demo-package'),
     oJSONObj.AddParam('bcp_file_name', ''),

     oCustomizingObjects := oJSONObj.AddComplexParam('customizing-objects'),

     oTableArray := oCustomizingObjects.AddArrayElement('tables'),   // TBeasCustomServiceParamItem

     if bAllTables then
        for i := 1 to 999 do
           oTableInfo := GetTableInfo(i),
           if not empty(oTableInfo) and not (oTableInfo.TableDef.TableName $ '/DABGRD.ADT/DABGRS.ADT/') then
              AppendSingleTableToTablesObject(oTableArray, oTableInfo.TableDef.TableName),
           endif,
        next,
     else
        // Tabellen des packages 'ausnahme-meldungen'
        AppendSingleTableToTablesObject(oTableArray, 'KDNDAM.ADT'),

        // Tabellen des packages 'protokoll-bestandsberichtigung'
        // AppendSingleTableToTablesObject(oTableArray, 'KDNBBP.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'KDNBBPD.ADT'),

        // Tabellen des packages 'taskplaner'
        // AppendSingleTableToTablesObject(oTableArray, 'TSKPLSCHED.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'TSKPLTASK.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'TSKPLLOG.ADT'),

        // Tabellen des packages 'edi'
        // AppendSingleTableToTablesObject(oTableArray, 'EDITRCH.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIMSG.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIBSP.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIPROF.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIPART.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIDOCL.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIDOC.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIHEAD.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDIPOS.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDISEGM.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'EDISCHM.ADT'),

        // Tabellen des packages 'layout übersetzungen' (vor der Standardisierung...)
        // AppendSingleTableToTablesObject(oTableArray, 'KDNLBK.ADT'),
        // AppendSingleTableToTablesObject(oTableArray, 'KDNLBP.ADT'),
     endif,

     Result := oJSONObj.CbToJSONStringIndent(),
  always
     DestroyObject(oJSONObj),
  stopseq,
end,

startseq
   WriteLn( BuildDemo_BePackageJson(false) ),
onerror
   SetError(GU_ShowStdErrorMessage(GetErrorText(), GetErrorObj(), true)),
stopseq,
