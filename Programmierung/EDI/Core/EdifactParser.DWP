|
   oAbstractSyntaxTree:P1, cEDIMessage:P2, aList:P3, cMode:P4,
   aEDIMessageLines, nLineIndex,
   cValSep, nState,
   aRes, nMode, nStateNew, oAktParent, oNewNode, cLine, bUTF8,

   // Delimiters
   m_cSegmentTerminator
|

//Allgemeiner EDI-Parser: Liest die Datei cFileName in eine Baumstruktur nach dem Schema aus aList ein.
//unterstützt nun auch unterschiedliche Trennzeichen (cValSep) /PH 02.11.10
//cMode: X12 oder EDIFACT

function EDI_StateEngine(nState, cSegment, aList)
   |nParent, aBuf, nPos|
   //Rückgabe: {Neuer Status, Modus}
   //Modus: 1=Gleiche Ebene, gleicher Vater, 2=Ebene höher, 3=SG Wiederholung, 4=Ebene tiefer, 5=Raus und gleich wieder rein

   //Schritt 1: Wiederholung?
                                                                                //writeln(nState, cSegment),
   if cSegment $ 'ISA/IEA' and cMode=='X12' then  //Bei X12 Nachrichtentrailer ignorieren
      result:={nState, 0},
      exit,
   endif,
   nParent:=0,
   if nState>0 then
      aBuf:=aList[nState],
      nParent:=aBuf[4],
   endif,
   while !empty(nParent) do
      aBuf:=aList[nParent+1],
      if aBuf[1]=cSegment then
         aBuf:=aList[nParent],
         if aBuf[2] then  //Wiederholungen erlaubt?
            result:={nParent+1, 3},
            exit,
         endif,
      endif,
      nParent:=aList[nParent, 4],
   end,
   //Schritt2: Sequentiell nach vorne suchen
   nPos:=nState,
   if nPos=0 then
      nPos:=1,
   else
      if !aList[nPos,2] then  //keine Wiederholungen erlaubt?
         nPos++,
      endif,
   endif,
   while true do
      if aList[nPos, 1] = cSegment then //Typ stimmt?
         if nState=0 then
            result:={nPos, 1},
            exit,
         endif,
         if aList[nPos, 4]=aList[nState,4] then //Gleicher Vater?
            result:={nPos, 1},
         else
            result:={nPos, 2},
         endif,
         exit,
      endif,
      if nPos>=alen(aList) then
         result:={-1, -1},
         exit,
      endif,
      if aList[nPos, 1]='SG' then
         nPos++,
         if aList[nPos, 1] = cSegment then //Typ stimmt?
            if nState=0 then
               result:={nPos, 4},
               exit,
            endif,
            if aList[nPos-1,4]=aList[nState,4] then
               result:={nPos, 4},
            else
               result:={nPos, 5},
            endif,
            exit,
         endif,
         nPos--,
         nPos:=aList[nPos, 5], //Auf letztes Element des übergeordneten Segments springen, da Erstes Element nicht passt
      endif,
      nPos++,
      if nPos>alen(aList) then
         result:={-1, -1},
         exit,
      endif,
   end,
end,

function EDI_FindParent(nSIndex, oParNode)  //Sucht einen Vaterknoten mit dem übergebenen Strukturindex
   |oNode|
   oNode:=oParNode,
   while !empty(oNode) do
      if val(oNode.Value) = nSIndex then
         result:=oNode,
         exit,
      endif,
      oNode:=oNode.Parent,
   end,
end,

function ReadSegment(cSegment)
   |cTyp,nStateNew, nParentID|

   cTyp:=strtoken(cSegment, cValSep, 1),
   aRes:=EDI_StateEngine(nState, cTyp, aList),
   nMode:=aRes[2],
   nStateNew:=aRes[1],
   SetErrorIf(
      nStateNew = -1,
      'EDI::Core::Parser: Invalid state returned by state-engine: Segment not found in scheme: ' + cTyp
   ),

   case nMode
      of 1:: oNewNode:=oAktParent.AddChild,     //Gleiche Ebene
             oNewNode.Text:=cSegment,

      of 4:: oNewNode:=oAktParent.AddChild,     //Eine Ebene Tiefer
             oNewNode.Text:=aList[nStateNew-1,1],
             oNewNode.Value:=str(nStateNew-1),   //In Value wird für jeden SG Knoten dessen SI gespeichert
             oAktParent:=oNewNode,
             oNewNode:=oAktParent.AddChild,
             oNewNode.Text:=cSegment,

      of 2:: oAktParent:=EDI_FindParent(aList[nStateNew,4], oAktParent),   //Ebene Raus
             if empty(oAktParent) then
                SetError('Interner EDI-Fehler (1)'),
             endif,
             oNewNode:=oAktParent.AddChild,
             oNewNode.Text:=cSegment,

      of 3:: nParentID:=aList[nStateNew,4],                                        //SG-Wiederholung
             nParentID:=aList[nParentID,4],
             oAktParent:=EDI_FindParent(nParentID, oAktParent),
             if empty(oAktParent) then
                SetError('Interner EDI-Fehler (1)'),
             endif,
             oNewNode:=oAktParent.AddChild,
             oNewNode.Text:=aList[nStateNew-1,1],
             oNewNode.Value:=str(nStateNew-1),
             oAktParent:=oNewNode,
             oNewNode:=oAktParent.AddChild,
             oNewNode.Text:=cSegment,

      of 5:: nParentID:=aList[nStateNew,4],
             nParentID:=aList[nParentID,4],
             oAktParent:=EDI_FindParent(nParentID, oAktParent),   //Raus und Rein,
             if empty(oAktParent) then
                SetError('Interner EDI-Fehler (1)'),
             endif,
             oNewNode:=oAktParent.AddChild,
             oNewNode.Text:=aList[nStateNew-1,1],
             oNewNode.Value:=str(nStateNew-1),
             oAktParent:=oNewNode,
             oNewNode:=oAktParent.AddChild,
             oNewNode.Text:=cSegment,
   endcase,
   nState:=nStateNew,
end,

//******************************************************************************
// Alle Segmente der EDI-Nachricht in ein Array extrahieren.
// @result: array - Array mit allen Segmenten aus der EDI-Nachricht
//******************************************************************************
function BuildSegmentsArray(cEDIMessage:C, cSegmentTerminator:C)
| i, cSegmentString |

   //***************************************************************************
   // Diese Funktion entfernt alle potentiellen Whitespaces am Anfang des
   // übergebenen Segment-String.
   //
   // Alle Zeichen mit einem ASCII-Wert kleiner als 32, werden als
   // Whitespaces behandelt und vom Segment-String abgeschnitten.
   //
   // @result: string
   //***************************************************************************
   function StripPrecedingWhitespaces(cSegmentString:C)
   | i, nAsciiCode, nStripPosition |

      nStripPosition := 0,
      for i := 1 to Len(cSegmentString) do
         nAsciiCode := Asc(SubStr(cSegmentString, i, 1)),
         if nAsciiCode < 32 then
            nStripPosition := i,
         else
            break,
         endif,
      next,

      if nStripPosition > 0 then
         result := SubStr(cSegmentString, nStripPosition + 1),
      else
         result := cSegmentString,
      endif,
   end,

   result := {},
   for i := 1 to TokenCount(cEDIMEssage, cSegmentTerminator) do
      cSegmentString := StripPrecedingWhitespaces(Token(cEDIMessage, cSegmentTerminator, i)),
      if not empty(cSegmentString) then
         AAdd(result, cSegmentString + cSegmentTerminator),
      endif,
   next,
end,

//******************************************************************************
// TODO: Diese Funktion ist an dieser Stelle sinnlos, da zu diesem Zeitpunkt
//       garkein UNA-Segment mehr im MessageString vorhanden ist.
//       Stattdessen sollte auf die EDI_Edifact_Context_Get*()-Funktionen
//       zurückgegriffen werden!
//******************************************************************************
// Diese Funktion extrahiert die zu verwendenden Trennzeichen aus der
// EDI-Nachricht - sofern diese angegeben sind.
//
// @result: null
//******************************************************************************
function ExtractDelimiters(cMessageString:C)
| cDummy |

   EDI_Edifact_MessageString_GetDelimiters(
      cMessageString,
      m_cSegmentTerminator, // Aktuell wird nur der Segmenttrenner benötigt
      cDummy,
      cDummy,
      cDummy,
      cDummy,
      cDummy
   ),
end,

//##############################################################################
//##############################################################################
// Hauptprogramm
//##############################################################################
//##############################################################################

// Validierungen
SetErrorIf(
   empty(oAbstractSyntaxTree),
   'Parameter oAbstractSyntaxTree (P1) must not be empty'
),
SetErrorIf(
   not ClassOf(oAbstractSyntaxTree, 'TTreeViewEx'),
   'Parameter oAbstractSyntaxTree (P1) must be an object of type TTreeViewEx'
),
SetErrorIf(
   empty(aList),
   'Parameter aList (P3) must contain EDI schema information'
),

// Startknoten
oAktParent:=CollAdd(oAbstractSyntaxTree.Items),
oAktParent.Text:='ROOT',
oAktParent.Value:='0',

//Start
nState:=0,
cValSep:='',
bUTF8:=false,

// Trennzeichen aus der EDI-Nachricht extrahieren
ExtractDelimiters(cEDIMessage),

aEDIMessageLines := BuildSegmentsArray(cEDIMessage, m_cSegmentTerminator),
for nLineIndex := 1 to ALen(aEDIMessageLines) do
   cLine := trim(aEDIMessageLines[nLineIndex]),
   if asc(substr(cLine, 1,1))=239 then  //Binäre Zeichenfolge am Dateianfang ausblenden
      cLine:=substr(cLine, 4),
      bUTF8:=true,
   endif,
   if bUTF8 then
      cLine:=utf8toansi(cLine),
   endif,
   cValSep := iif(Empty(cValSep), substr(cLine, 4,1), cValSep),
   ReadSegment(cLine),
next,

