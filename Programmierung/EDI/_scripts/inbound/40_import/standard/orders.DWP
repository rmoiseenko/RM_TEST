//##############################################################################
//##############################################################################
//
// Prozessschritt: Inbound Import vom Inhouseformat in be-Aufträge
//
//------------------------------------------------------------------------------
//
// Beschreibung:
//   Dieses Programm verarbeitet das inhouse-Format und übersetzt die
//   Daten in Auftragsdaten (Dab050, Dab055)
//
// Rückgabe:
//   array - EDIProcessStatus
//     {
//        {'EDIProcessStatus.status',       <integer>},
//        {'EDIProcessStatus.errorMessage', <string>},
//        {'EDIProcessStatus.warnMessage',  <string>}
//     }
//
//##############################################################################
//##############################################################################

|
   m_oDM:P1,
   m_nEDIMSGId:P2,
   m_oProgressCallback:P3,

   m_oDM_Orders,                    // Eigenes DM für Auftragserfassung, Erklärung siehe bei Create()...
   m_bAuftragsTransaktionAbbrechen,
   m_aProcessResult
|

//##############################################################################
//##############################################################################
// Funktionen
//##############################################################################
//##############################################################################

//******************************************************************************
// Diese Funktion legt für jeden Inhouse-Position einen DAB055 Satz an
// @Result: null - keine Rückgabe
//******************************************************************************
function CreatePos(oDM_Orders:O, oDM:O, oEDIPOS:O, nOrderNo:N)
| oDAB055, aPosData, cArtnr, nPosNr, nEdiPreis, cPOSErrorText, nPOSStatus, cPosWarningText |

   // Tabellen
   oDAB055  := MyGetTable(oDM_Orders, waDAB055,  ''),
   startseq
      // Positonsdaten auslesen
      aPosData   := StrToArr(oEDIPOS:DATA),                              // prs('artnr', EDI_InhouseFormat_GetAssert(aPosData,"DAB055.ARTNR")),
      cArtnr     := EDI_InhouseFormat_GetAssert(aPosData,"DAB055.ARTNR"),

      // Positions-Anlage absichern, bei Fehlern diese in der EDIPOS vermerken und mit nächster Pos weiter versuchen
      startseq
         // Auftrag anlegen
         nPOSStatus         := gl_EDI_ProcessStatus_ok,
         cPOSErrorText      := '',
         cPosWarningText    := '',

         nPosnr             := EDI_InhouseFormat_GetAssert(aPosData, "DAB055.POSNR"),
         AufPosNeu2(oDM_Orders, nOrderno, cArtnr, true, true, true, true, nPosnr),
         oDAB055:BMENGE     := EDI_InhouseFormat_GetAssert(aPosData, "DAB055.BMENGE"),
         oDAB055:ME         := EDI_InhouseFormat_GetAssert(aPosData, "DAB055.ME"),

         // oDAB055:X_KDARTNR  := EDI_InhouseFormat_GetAssert(aPosData,"DAB055.X_KD_ARTNR"),

         AufPosPost2(oDM_Orders, nOrderNo, nPosnr, false, true, true, false),

         // Warnung erzeugen, wenn EDI Preis vom be Preis abweicht
         nEdiPreis := ToFloat(EDI_InhouseFormat_Get(aPosData, 'DAB055.EPREIS', 0)),
         if nEdiPreis <> 0 and nEdiPreis <> oDAB055:EPREIS then
            cPosWarningText := 'EDI Preis (' + FormatStd(nEdiPreis, 2) + ') weicht von be Preis (' + FormatStd(oDAB055:EPREIS, 2) + ') ab.',
            nPOSStatus      := gl_EDI_ProcessStatus_Warning,
         endif,
      onerror
         m_bAuftragsTransaktionAbbrechen := true,
         nPOSStatus                      := gl_EDI_ProcessStatus_Error,
         cPOSErrorText                   := GU_ShowStdErrorMessage(GetErrorText(), GetErrorObj(), true),
         // Fehler hier NICHT wieder auslösen, wir wollen die nächsten Position noch anlegen (Transaktion wird am Ende eh abgebrochen)
      stopseq,

   always
      // EDIPOS mit Auftragspositionsnummer und DAB055:ID versorgen
      oEDIPOS.CbEdit(),
      if not m_bAuftragsTransaktionAbbrechen then
        oEDIPOS:APNUMMER   := oDAB055:APNUMMER,
        oEDIPOS:DAB055_ID  := oDAB055:ID,
      endif,
      oEDIPOS:STATUS       := nPOSStatus,

      if not empty(cPosWarningText) then
         oEDIPOS:WARN_MSG  := cPosWarningText + crlf + oEDIPOS:WARN_MSG,
      endif,
      if not empty(cPosErrorText) then
         oEDIPOS:ERROR_MSG := cPosErrorText   + crlf + oEDIPOS:ERROR_MSG,
      endif,
      oEDIPOS.CbPost(),

      DestroyObject(oDAB055),
   stopseq,
end,

//******************************************************************************
// Diese Funktion legt für jeden Inhouse-Header einen DAB050 Satz an
// @Result: null - keine Rückgabe
//******************************************************************************
function CreateHeader(oDM_Orders:O, oDM:O, oEDIHEAD:O)
| oDAB050, oDAB000, oMEM050, oEDIPOS, aHeadData, nOrderNo, nKDNR, cTermin, cHeadErrorText, bHasWarningsInPositions, cBestDat |

   // Tabellen
   oEDIPOS   := MyGetTable(oDM, waEDIPOS,  ''),                                   // prs('CreateHeader',  'start'),
   oDAB050   := MyGetTable(oDM_Orders, waDAB050,  ''),
   oDAB000   := MyGetTable(oDM_Orders, waDAB000,  ''),
   oMem050   := CreateObject('TMemCalcTable', 'oMem050', oDM_Orders),
   oEDIPOS.CbIndexName := 'EDIHEAD_ID',
   Startseq,
      // Auftrag anlegen
      cHeadErrorText          := '',
      bHasWarningsInPositions := false,
      startseq
         // Kopfdaten auslesen
         aHeadData := StrToArr(oEDIHEAD:DATA),
         nKDNR     := EDI_InhouseFormat_GetAssert(aHeadData, 'DAB050.KDNR'),

         nOrderNo           := AufKopfNeu(nKdnr,'N',0,oDAB000,oDAB050,oMem050),
         cBestDat           := EDI_InhouseFormat_Get(aHeadData, 'DAB050.KDBEST_DAT', ''),    WriteLn(cBestDat),
         oDAB050:KDBEST_DAT := iif(not empty(cBestDat), DtoC(StoD(cBestDat)), oDAB050:KDBEST_DAT),
         oDAB050:KDBEST_NR  := EDI_InhouseFormat_Get(aHeadData, 'DAB050.KDBEST_NR',  ''),
         cTermin            := EDI_InhouseFormat_Get(aHeadData, 'DAB050.TERMIN',     ''),
         if not empty(cTermin) then
            oDAB050:TERMIN  := SubStr(cTermin, 7, 2) + '.' + SubStr(cTermin, 5, 2) + '.' + SubStr(cTermin, 3, 2),
         endif,
         if not empty(EDI_InhouseFormat_Get(aHeadData,"DAB050.LNAME1", '')) then
            oDAB050:LNAME1     := EDI_InhouseFormat_Get(aHeadData, "DAB050.LNAME1",   ''),
            oDAB050:LSTRASSE   := EDI_InhouseFormat_Get(aHeadData, "DAB050.LSTRASSE", ''),
            oDAB050:PLZORT     := EDI_InhouseFormat_Get(aHeadData, "DAB050.LPLZORT",  ''),
         else
            // Lieferadresse mit AB-Adresse vorbelegen, wenn keine Lieferadresse im Stamm definiert
            if empty(oDAB000:LNAME1) then
               oDAB050:LNAME1   := oDAB000:NAME1,
               oDAB050:LNAME2   := oDAB000:NAME2,
               oDAB050:LNAME3   := oDAB000:NAME3,
               oDAB050:LSTRASSE := oDAB000:STRASSE,
               oDAB050:LPLZORT  := oDAB000:PLZORT,
            endif,
         endif,
         oDAB050:LLANDNR  := e2v(Alltrim(oDAB000:LANDNR), '004'), // DE annehmen, wenn in der Adresse kein Land drin ist
         
         AufKopfPost(nOrderNO,oDAB000,oDAB050,oMem050),
      onerror
         m_bAuftragsTransaktionAbbrechen := true,
         cHeadErrorText                  := GU_ShowStdErrorMessage(GetErrorText(), GetErrorObj(), true),
         raise(),
      stopseq,      

      // Alle PosDatensätze zum Header durchgehen
      oEDIPOS.CbSetRangeEx({oEDIHEAD:ID}),
      while not oEDIPOS.Cbeof do                                                // prs('CreateHeader',  'while vor createItems'),
         CreatePos(oDM_Orders, oDM, oEDIPOS, nOrderNo),
         bHasWarningsInPositions := bHasWarningsInPositions or oEDIPOS:STATUS = gl_EDI_ProcessStatus_Warning,
         oEDIPOS.CbNext(),
      end,
      oEDIPOS.CbCancelRange(),                                                  // prs('CreateHeader',  'cancel range'),
   always
      // EDIHead mit Auftragsnummer und DAB050:ID versorgen
      oEDIHEAD.CbEdit(),
      if m_bAuftragsTransaktionAbbrechen then
         oEDIHEAD:STATUS    := gl_EDI_ProcessStatus_Error,
         oEDIHEAD:ERROR_MSG := 'Fehler bei der Auftrags-Anlage, der Auftrag wurde NICHT angelegt. ' + crlf + cHeadErrorText,
      else
         oEDIHEAD:ANUMMER   := oDAB050:ANUMMER,
         oEDIHEAD:DAB050_ID := oDAB050:ID,
         oEDIHEAD:STATUS    := iif(bHasWarningsInPositions, gl_EDI_ProcessStatus_Warning, gl_EDI_ProcessStatus_Ok),
      endif,
      oEDIHEAD.CbPost(),

      destroyobject(oMEM050),
      destroyobject(oDAB050),
   stopseq,
end,

//******************************************************************************
// Diese Funktion überführt alle Inhouse-Sätze zu einer EDI Nachricht in Kd. Aufträge
// @Result: KVU-Array {'WARNINGS', <Anzahl der Warnungen>}
//******************************************************************************
function ImportEdifactMessage_Internal(oDM_Orders:O, oDM:O, nEDIMSGId:N)
| oEDIMSG, oEDIHEAD, nWarnings |

   oEDIHEAD := MyGetTable(oDM, waEDIHEAD, ''),
   oEDIMSG  := MyGetTable(oDM, waEDIMSG,  'EDIMSG_SEEK'),

   oEDIHEAD.CbIndexname := 'EDIMSG_ID',
   oEDIMSG.CbIndexName  := 'ID',

   SetErrorIf(not oEDIMSG.CbFindKey({nEDIMSGId}), 'EDIMSG record with ID <' + str(nEDIMSGId) + '> does not exist'),
   
   // alle Header-Datensätze zur Message ID durchgehen und Aufträge anlegen
   nWarnings := 0,
   oEDIHEAD.CbSetRangeEx({nEDIMSGId}),
   while not oEDIHEAD.CbEoF do
      CreateHeader(oDM_Orders, oDM, oEDIHEAD),
      if oEDIHEAD:STATUS = gl_EDI_ProcessStatus_Warning then
         nWarnings++,
      endif,
      oEDIHEAD.CbNext(),
   end,
   oEDIHEAD.CbCancelRange(),

   Result := {},
   KVU_Set(Result, 'WARNINGS', nWarnings),
end,

//******************************************************************************
// Diese Funktion importiert eine EDIFACT Nachricht mit der übergebenen
// EDIMSG-ID und erstellt auf Basis des bereits erstellten Inhouseformats den
// Kundenauftrag (DAB050,DAB055)
//
// @Result: array - EDIProcessStatus
//******************************************************************************
function ImportEdifactMessage(oDM:O, nEDIMSGId:N, oProgressCallback:O)
| oEDIMessage, aRes |

   Result := {},

   // Für die Auftrags-Erstellung nutzen wir eigenes DM, damit die Auftrags-Daten im Fehlerfall zurück
   // gesetzt werden könne, die Fehler-Texte in der EDIHEAD / EDIPOS aber committed werden.
   m_oDM_Orders := CreateObject("TBeDbGet", "CREATE_ORDER"),
   startseq
      oEDIMessage := EDI_Message_Open(oDM, nEDIMSGId),
      startseq
         startseq
            m_oDM_Orders.CbTransaction_Begin(),
            startseq
               m_bAuftragsTransaktionAbbrechen := false,

               aRes := ImportEdifactMessage_Internal(m_oDM_Orders, m_oDM, nEDIMSGId),

               // Wir versuchen, alle Positionen zu verarbeiten und brechen die Transaktion
               // erst ganz am Ende ab, sofern mind. ein Fehler aufgetreten ist.
               // -> Nur so kann man alle Fehler sehen, die potentiell auftreten, wenn man den Auftrag anlegt.
               if not m_bAuftragsTransaktionAbbrechen then
                  m_oDM_Orders.CbTransaction_Commit(),
               endif,
            always
               if m_oDM_Orders.CbTransaction_TryRollback() then
                  DbResetDM(m_oDM_Orders),
                  SetError('Fehler bei der Auftrags-Anlage, der Auftrag wurde NICHT angelegt.'),
               endif,
            stopseq,

            EDI_Message_Save(oEDIMessage, gl_EDI_ProcessStep_EDIMSG_Inbound_Imported),

            if KVU_GetAssert(aRes, 'WARNINGS') > 0 then
               EDI_ProcessResult_SetWarning(Result, 'Es sind Warnungen vorhanden, prüfen Sie Kopf- und Positions-Datensätze des Inhouse-Formats.'),
            else
               EDI_ProcessResult_SetSuccess(Result),
            endif,
         onerror
            EDI_ProcessResult_SetError(Result, GetErrorText(GetErrorObj())),
            EDI_Message_LogErrorAndSave(oEDIMessage, GetErrorObj()),
         stopseq,

         // Status-Ergebnis in die Nachrichten-Tabellen schreiben
         EDI_ProcessResult_WriteStatusToTable(Result, KVU_GetAssert(oEDIMessage, 'ediMessage.edimsgTable')),
      always
         EDI_Message_Destroy(oEDIMessage),
      stopseq,
   always
      DestroyObject(m_oDM_Orders),
   stopseq,
end,

//##############################################################################
//##############################################################################
// Hauptprogramm
//##############################################################################
//##############################################################################

m_aProcessResult     := {},

if EditorMode() and empty(m_oDM) then
   m_oDM       := CreateObject('TBeDbGet'),
   m_nEDIMSGId := 15,
endif,

m_oDM.CbTransaction_Begin(),
startseq
   m_aProcessResult := ImportEdifactMessage(m_oDM, m_nEDIMSGId, m_oProgressCallback),
   m_oDM.CbTransaction_Commit(),
always
   if m_oDM.CbTransaction_TryRollback() then
      DbResetDM(m_oDM),
   endif,
stopseq,

m_aProcessResult
